<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Progress Tracker UI</title>
    <style>
        :root {
            --bg-0: #f4efe6;
            --bg-1: #fffaf2;
            --panel: #ffffff;
            --line: #d9d0c2;
            --text-strong: #1f2933;
            --text-soft: #5a6670;
            --accent: #1f7a8c;
            --accent-strong: #155664;
            --warning: #b96f00;
            --danger: #a42f2f;
            --ok: #2f7d32;
            --shadow: 0 8px 24px rgba(31, 41, 51, 0.08);
            --radius: 14px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            font-family: "IBM Plex Sans", "Avenir Next", "Segoe UI", sans-serif;
            color: var(--text-strong);
            background:
                radial-gradient(1100px 380px at 50% -240px, #ffffff 0%, var(--bg-0) 70%),
                linear-gradient(180deg, var(--bg-0) 0%, var(--bg-1) 100%);
        }

        .app {
            max-width: 1240px;
            margin: 0 auto;
            padding: 18px;
            display: grid;
            gap: 14px;
        }

        .topbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: var(--radius);
            padding: 12px 16px;
            box-shadow: var(--shadow);
        }

        .title {
            margin: 0;
            font-size: 1.15rem;
            font-weight: 700;
            letter-spacing: 0.01em;
        }

        .status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            border-radius: 999px;
            border: 1px solid transparent;
            padding: 6px 10px;
            font-size: 0.87rem;
            font-weight: 600;
            color: var(--text-soft);
            background: #f7f3ea;
        }

        .status::before {
            content: "";
            width: 8px;
            height: 8px;
            border-radius: 999px;
            background: currentColor;
            opacity: 0.9;
        }

        .status.info {
            color: var(--accent-strong);
            border-color: rgba(21, 86, 100, 0.28);
            background: rgba(31, 122, 140, 0.08);
        }

        .status.success {
            color: var(--ok);
            border-color: rgba(47, 125, 50, 0.28);
            background: rgba(47, 125, 50, 0.09);
        }

        .status.warn {
            color: var(--warning);
            border-color: rgba(185, 111, 0, 0.3);
            background: rgba(185, 111, 0, 0.1);
        }

        .status.error {
            color: var(--danger);
            border-color: rgba(164, 47, 47, 0.3);
            background: rgba(164, 47, 47, 0.1);
        }

        /* å†²çªçŠ¶æ€ - ç´«è‰²ä¸»é¢˜ï¼Œå‘¼å¸åŠ¨ç”»å¼ºè°ƒ */
        .status.conflict {
            color: #9333ea;
            border-color: rgba(147, 51, 234, 0.3);
            background: rgba(147, 51, 234, 0.1);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* [ä¿®æ­£3] ç‹¬ç«‹å†²çª Drawer CSS è¡¥é½ï¼ˆå¤ç”¨ç°æœ‰æ ·å¼å˜é‡ï¼‰ */
        .drawer-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(31, 41, 51, 0.5);
            backdrop-filter: blur(4px);
            z-index: 99;
        }

        .drawer-panel {
            position: fixed;
            top: 0;
            right: -420px;
            width: 420px;
            height: 100vh;
            background: var(--panel);
            border-left: 1px solid var(--line);
            box-shadow: -8px 0 24px rgba(31, 41, 51, 0.12);
            transition: right 280ms cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        /* [P1 ä¿®å¤] Drawer æ‰“å¼€ç±»åä¸ CSS é€‰æ‹©å™¨ä¸€è‡´ */
        .drawer.open .drawer-panel {
            right: 0;
        }

        .drawer-header {
            border-bottom: 1px solid var(--line);
            padding: 14px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #ffffff;
        }

        .drawer-header h3 {
            margin: 0;
            font-size: 1.1rem;
        }

        .drawer-close-btn {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: none;
            background: transparent;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .drawer-close-btn:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        /* å†²çª Drawer æ ·å¼ */
        .conflict-drawer {
            padding: 20px;
        }

        .conflict-table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
        }

        .conflict-table td {
            padding: 8px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .conflict-label {
            color: #6b7280;
            font-size: 13px;
            width: 120px;
        }

        .conflict-value {
            color: #111827;
            font-size: 14px;
            font-weight: 500;
        }

        .conflict-actions {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .conflict-action-btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .conflict-action-btn.primary {
            background: #9333ea;
            color: white;
        }

        .conflict-action-btn.primary:hover {
            background: #7e22ce;
        }

        .conflict-action-btn.secondary {
            background: white;
            color: #dc2626;
            border: 1px solid #dc2626;
        }

        .conflict-action-btn.secondary:hover {
            background: #fef2f2;
        }

        /* å†²çªå¤„ç†ä¸­çŠ¶æ€ */
        .conflict-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .workspace {
            min-height: 72vh;
            display: grid;
            grid-template-columns: minmax(220px, 300px) minmax(0, 1fr);
            gap: 14px;
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .panel-head {
            border-bottom: 1px solid var(--line);
            padding: 10px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .panel-head h2 {
            margin: 0;
            font-size: 0.96rem;
            letter-spacing: 0.01em;
        }

        .actions {
            display: inline-flex;
            gap: 6px;
        }

        button {
            border: 1px solid var(--line);
            background: #ffffff;
            color: var(--text-strong);
            border-radius: 10px;
            padding: 6px 10px;
            font-size: 0.84rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 120ms ease, border-color 120ms ease, color 120ms ease;
        }

        button:hover {
            border-color: var(--accent);
            color: var(--accent-strong);
            background: rgba(31, 122, 140, 0.08);
        }

        .doc-list {
            list-style: none;
            margin: 0;
            padding: 10px;
            display: grid;
            gap: 6px;
            max-height: calc(72vh - 58px);
            overflow: auto;
        }

        .doc-list li {
            margin: 0;
        }

        .doc-item {
            width: 100%;
            border: 1px solid var(--line);
            border-radius: 10px;
            padding: 8px;
            cursor: pointer;
            display: grid;
            gap: 4px;
            text-align: left;
            transition: border-color 120ms ease, background 120ms ease;
        }

        .doc-item:hover {
            border-color: var(--accent);
            background: rgba(31, 122, 140, 0.07);
        }

        .doc-item:focus-visible {
            outline: 2px solid var(--accent-strong);
            outline-offset: 2px;
        }

        .doc-item.active {
            border-color: var(--accent-strong);
            background: rgba(31, 122, 140, 0.12);
        }

        .doc-name {
            margin: 0;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .doc-meta {
            margin: 0;
            font-size: 0.77rem;
            color: var(--text-soft);
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
        }

        .editor-head {
            border-bottom: 1px solid var(--line);
            padding: 10px 12px;
            display: grid;
            gap: 2px;
        }

        .active-path {
            margin: 0;
            font-size: 0.9rem;
            font-weight: 700;
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .active-time {
            margin: 0;
            color: var(--text-soft);
            font-size: 0.79rem;
        }

        .active-hint {
            margin: 0;
            color: var(--accent-strong);
            font-size: 0.79rem;
            font-weight: 600;
        }

        .refresh-meta {
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            font-size: 0.74rem;
            color: var(--text-soft);
            padding: 0 6px;
            white-space: nowrap;
        }

        .editor {
            margin: 0;
            padding: 14px;
            overflow: auto;
            white-space: normal;
            line-height: 1.6;
            font-size: 0.91rem;
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            min-height: calc(72vh - 58px);
            background-image:
                linear-gradient(180deg, rgba(31, 122, 140, 0.025) 1px, transparent 1px);
            background-size: 100% 1.65rem;
        }

        .empty {
            margin: 0;
            color: var(--text-soft);
            font-style: italic;
        }

        .editor-line {
            display: block;
            min-height: 1.6rem;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .editor-line.checkbox-line {
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .checkbox-btn {
            width: 28px;
            min-width: 28px;
            height: 28px;
            border-radius: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            font-size: 1rem;
            line-height: 1;
        }

        .checkbox-btn.status-space {
            color: var(--text-soft);
        }

        .checkbox-btn.status-slash {
            color: #0d9488;
        }

        .checkbox-btn.status-x {
            color: var(--ok);
        }

        .checkbox-btn.status-dash {
            color: #0f766e;
        }

        .checkbox-btn.status-bang {
            color: var(--danger);
        }

        .checkbox-btn.status-question {
            color: #7c3aed;
        }

        .checkbox-text {
            flex: 1;
            min-width: 0;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .checkbox-menu {
            position: fixed;
            z-index: 200;
            min-width: 180px;
            background: #ffffff;
            border: 1px solid var(--line);
            border-radius: 10px;
            box-shadow: var(--shadow);
            padding: 6px;
            display: none;
        }

        .checkbox-menu.open {
            display: block;
        }

        .checkbox-menu-item {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 8px;
            border: none;
            background: transparent;
            border-radius: 8px;
            padding: 8px 10px;
            text-align: left;
            font-size: 0.83rem;
            color: var(--text-strong);
        }

        .checkbox-menu-item:hover {
            background: rgba(31, 122, 140, 0.08);
            color: var(--accent-strong);
        }

        .checkbox-menu-icon {
            width: 1.2rem;
            text-align: center;
        }

        .checkbox-menu-key {
            margin-left: auto;
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            font-size: 0.76rem;
            color: var(--text-soft);
        }

        @media (max-width: 900px) {
            .workspace {
                grid-template-columns: 1fr;
                min-height: auto;
            }

            .doc-list,
            .editor {
                max-height: 42vh;
                min-height: auto;
            }
        }

        /* ========== Status Bar ========== */
        .status-bar {
            display: flex;
            gap: 8px;
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: var(--radius);
            padding: 10px 12px;
            margin-bottom: 12px;
            box-shadow: var(--shadow);
            align-items: center;
        }

        .status-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid var(--line);
            background: #ffffff;
            text-align: left;
            flex: 1;
            min-width: 0;
            cursor: pointer;
            transition: all 120ms ease;
        }

        .status-item:hover {
            border-color: var(--accent);
            background: rgba(31, 122, 140, 0.08);
            transform: translateY(-1px);
        }

        .status-label {
            font-size: 0.75rem;
            color: var(--text-soft);
            font-weight: 600;
            letter-spacing: 0.02em;
        }

        .status-value {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--text-strong);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Status colors */
        .status-value.ok { color: #10b981; }
        .status-value.warn { color: #f59e0b; }
        .status-value.error { color: #ef4444; }

        .status-refresh {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 1px solid var(--line);
            background: #ffffff;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 120ms ease;
        }

        .status-refresh:hover {
            background: var(--accent);
            color: #ffffff;
        }

        .status-refresh.spinning {
            animation: refresh-spin 420ms linear;
        }

        @keyframes refresh-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* ========== Drawer ========== */
        .drawer {
            position: fixed;
            top: 0;
            right: -420px;
            width: 420px;
            height: 100vh;
            background: var(--panel);
            border-left: 1px solid var(--line);
            box-shadow: -8px 0 24px rgba(31, 41, 51, 0.12);
            transition: right 280ms cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        .drawer.open {
            right: 0;
        }

        .drawer-head {
            border-bottom: 1px solid var(--line);
            padding: 14px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #ffffff;
        }

        .drawer-head h2 {
            font-size: 1.1rem;
            margin: 0;
        }

        .drawer-close {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: none;
            background: transparent;
            font-size: 1.2rem;
            cursor: pointer;
        }

        .drawer-close:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        .drawer-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .drawer-summary {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-strong);
            margin: 0 0 16px 0;
            padding: 10px;
            background: rgba(31, 122, 140, 0.05);
            border-left: 3px solid var(--accent);
            border-radius: 6px;
        }

        .drawer-section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--text-strong);
            margin: 0 0 8px 0;
        }

        .section-text {
            font-size: 0.88rem;
            line-height: 1.6;
            color: var(--text-soft);
            margin: 0;
        }

        .section-list {
            margin: 0;
            padding-left: 20px;
            list-style: disc;
        }

        .section-list li {
            font-size: 0.88rem;
            line-height: 1.6;
            color: var(--text-soft);
            margin-bottom: 6px;
        }

        .section-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.88rem;
        }

        .section-table tr {
            border-bottom: 1px solid var(--line);
        }

        .section-table td {
            padding: 8px 4px;
            vertical-align: top;
        }

        .table-key {
            font-weight: 600;
            color: var(--text-soft);
            width: 35%;
        }

        .table-value {
            color: var(--text-strong);
        }

        .section-code {
            background: rgba(31, 41, 51, 0.04);
            border: 1px solid var(--line);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.82rem;
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            overflow-x: auto;
        }

        .feature-list {
            display: grid;
            gap: 8px;
        }

        .feature-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border: 1px solid var(--line);
            border-radius: 8px;
            background: #ffffff;
            font-size: 0.88rem;
        }

        .feature-item.completed {
            background: rgba(16, 185, 129, 0.05);
            border-color: rgba(16, 185, 129, 0.3);
        }

        .feature-id {
            font-weight: 700;
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            color: var(--accent-strong);
            min-width: 30px;
        }

        .feature-name {
            flex: 1;
            color: var(--text-strong);
        }

        .feature-status {
            font-size: 1.1rem;
            color: var(--ok);
        }

        .drawer-sources,
        .drawer-actions {
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--line);
        }

        .drawer-sources h4,
        .drawer-actions h4 {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-soft);
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .source-btn,
        .action-btn {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            margin-bottom: 8px;
            border: 1px solid var(--line);
            border-radius: 8px;
            background: #ffffff;
            text-align: left;
            cursor: pointer;
            transition: all 120ms ease;
        }

        .source-btn:hover,
        .action-btn:hover {
            border-color: var(--accent);
            background: rgba(31, 122, 140, 0.05);
        }

        .source-icon,
        .action-icon {
            font-size: 1.2rem;
        }

        .source-label,
        .action-label {
            font-size: 0.88rem;
            font-weight: 600;
            color: var(--text-strong);
        }

        .source-path {
            font-size: 0.78rem;
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            color: var(--text-soft);
            margin-left: auto;
        }

        .action-cmd {
            font-size: 0.78rem;
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            color: var(--text-soft);
            margin-left: auto;
            background: rgba(31, 41, 51, 0.04);
            padding: 4px 8px;
            border-radius: 4px;
        }

        /* Mobile adaptations */
        @media (max-width: 900px) {
            .status-bar {
                flex-wrap: wrap;
            }

            .status-item {
                flex: 1 1 calc(50% - 4px);
                min-width: 140px;
            }

            .drawer {
                width: 100%;
                right: -100%;
            }

            .drawer.open {
                right: 0;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="topbar">
            <h1 class="title">Progress Tracker UI</h1>
            <div id="status-pill" class="status info">Initializing</div>
        </header>

        <!-- Status Bar -->
        <section class="status-bar">
            <button class="status-item" data-panel="progress" title="ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…">
                <span class="status-label">æ€»è¿›åº¦</span>
                <span class="status-value" id="progress-value">-/-</span>
            </button>
            <button class="status-item" data-panel="next" title="ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…">
                <span class="status-label">ä¸‹ä¸€æ­¥</span>
                <span class="status-value" id="next-value">-</span>
            </button>
            <button class="status-item" data-panel="plan" title="ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…">
                <span class="status-label">è®¡åˆ’åˆè§„</span>
                <span class="status-value" id="plan-value">-</span>
            </button>
            <button class="status-item" data-panel="risk" title="ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…">
                <span class="status-label">é£é™©é˜»å¡</span>
                <span class="status-value" id="risk-value">-</span>
            </button>
            <button class="status-item" data-panel="snapshot" title="ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…">
                <span class="status-label">æœ€è¿‘å¿«ç…§</span>
                <span class="status-value" id="snapshot-value">-</span>
            </button>
            <button class="status-refresh" id="status-refresh-btn" title="åˆ·æ–°çŠ¶æ€">âŸ³</button>
        </section>

        <section class="workspace">
            <aside class="panel">
                <div class="panel-head">
                    <h2>Documents</h2>
                    <div class="actions">
                        <button id="refresh-files-btn" type="button">Refresh</button>
                        <span id="refresh-meta" class="refresh-meta">æœªåˆ·æ–°</span>
                    </div>
                </div>
                <ul id="doc-list" class="doc-list"></ul>
            </aside>

            <main class="panel">
                <div class="editor-head">
                    <p id="active-path" class="active-path">No document selected</p>
                    <p id="active-time" class="active-time">Choose a file from the left panel.</p>
                    <p id="editor-hint" class="active-hint">ä»… checkbox è¡Œï¼ˆ- [ ]ï¼‰å¯ç‚¹å‡»åˆ‡æ¢çŠ¶æ€ã€‚</p>
                </div>
                <div id="editor" class="editor"><p class="empty">Loading document list...</p></div>
            </main>
        </section>

        <!-- Drawer -->
        <aside class="drawer" id="status-drawer">
            <div class="drawer-head">
                <h2 id="drawer-title">è¯¦æƒ…</h2>
                <button class="drawer-close" id="drawer-close-btn">âœ•</button>
            </div>
            <div class="drawer-content" id="drawer-content">
                <!-- Dynamic content -->
            </div>
        </aside>

        <div class="checkbox-menu" id="checkbox-menu" role="menu" aria-label="Checkbox status menu"></div>

        <!-- å†²çªè§£å†³ Drawerï¼ˆç‹¬ç«‹äºçŠ¶æ€æ è¯¦æƒ… Drawerï¼‰ -->
        <div id="conflict-drawer" class="drawer" aria-hidden="true">
            <div class="drawer-backdrop" id="conflict-drawer-backdrop"></div>
            <div class="drawer-panel">
                <div class="drawer-header">
                    <h3 id="conflict-drawer-title">å†²çªè§£å†³</h3>
                    <button type="button" class="drawer-close-btn" id="conflict-drawer-close-btn" aria-label="å…³é—­">âœ•</button>
                </div>
                <div id="conflict-drawer-content" class="drawer-content"></div>
            </div>
        </div>
    </div>

    <script>
        (() => {
            const state = {
                files: [],
                activePath: null,
                activeRev: "",
                activeMtime: 0,
                selectedCheckboxLine: null,
                menuTargetLine: null,

                // å†²çªçŠ¶æ€æ‰©å±•ï¼ˆæ–°å¢ï¼‰
                conflictData: null,           // å†²çªå®Œæ•´ä¸Šä¸‹æ–‡
                pendingCheckboxUpdate: null,  // å¾…å¤„ç†çš„ checkbox æ›´æ–°
                isSaving: false,              // ä¿å­˜ä¸­æ ‡å¿—
                isResolvingConflict: false,   // å†²çªå¤„ç†ä¸­æ ‡å¿—
                hasPendingConflict: false,    // [ä¿®æ­£1] æœ‰å¾…å¤„ç†å†²çªæ—¶ä¿æŒé”å®š
                conflictRetryCount: 0,        // å†²çªé‡è¯•è®¡æ•°
                lastRequestId: 0,             // è¯·æ±‚åºåˆ—å·
                lastRequestTimestamp: 0       // ä¸Šæ¬¡è¯·æ±‚æ—¶é—´æˆ³
            };

            const ui = {
                statusPill: document.getElementById("status-pill"),
                docList: document.getElementById("doc-list"),
                activePath: document.getElementById("active-path"),
                activeTime: document.getElementById("active-time"),
                editorHint: document.getElementById("editor-hint"),
                editor: document.getElementById("editor"),
                refreshFilesBtn: document.getElementById("refresh-files-btn"),
                refreshMeta: document.getElementById("refresh-meta"),
                checkboxMenu: document.getElementById("checkbox-menu")
            };

            const checkboxStateMeta = [
                { char: " ", icon: "â˜", label: "æœªå¼€å§‹", key: "1", css: "status-space" },
                { char: "/", icon: "ğŸ”„", label: "è¿›è¡Œä¸­", key: "2", css: "status-slash" },
                { char: "x", icon: "â˜‘", label: "å·²å®Œæˆ", key: "3", css: "status-x" },
                { char: "-", icon: "â–", label: "ä¸é€‚ç”¨", key: "4", css: "status-dash" },
                { char: "!", icon: "âŒ", label: "é˜»å¡", key: "5", css: "status-bang" },
                { char: "?", icon: "â“", label: "å¾…ç¡®è®¤", key: "6", css: "status-question" }
            ];

            const checkboxStateLookup = new Map(
                checkboxStateMeta.map((item) => [item.char, item])
            );

            const keyboardStatusMap = {
                "1": " ",
                "2": "/",
                "3": "x",
                "4": "-",
                "5": "!",
                "6": "?"
            };

            function setStatus(text, tone = "info") {
                ui.statusPill.textContent = text;
                ui.statusPill.className = "status " + tone;
            }

            /**
             * ç»Ÿä¸€æ¸…ç†å†²çªçŠ¶æ€ï¼ˆP2 ä¿®å¤ï¼‰
             * é¿å…å„åˆ†æ”¯æ‰‹å·¥ reset é—æ¼å¯¼è‡´æ°¸ä¹…é”æ­»
             * @param options.keepDrawer - æ˜¯å¦ä¿æŒ Drawer æ‰“å¼€ï¼ˆé»˜è®¤ falseï¼‰
             * @param options.preserveConflictData - ä¿æŒå†²çªä¸Šä¸‹æ–‡ç”¨äºé‡è¯•ï¼ˆé»˜è®¤ falseï¼‰
             */
            function clearConflictState(options = {}) {
                const { keepDrawer = false, preserveConflictData = false } = options;

                // éé‡è¯•åœºæ™¯ï¼šæ¸…ç†å†²çªæ•°æ®
                if (!preserveConflictData) {
                    state.conflictData = null;
                    state.pendingCheckboxUpdate = null;
                    state.conflictRetryCount = 0;
                }

                // æ“ä½œæ€æ€»æ˜¯æ¸…ç†
                state.isResolvingConflict = false;
                state.isSaving = false;

                // ä»…åœ¨"ä¿ç•™ä¸Šä¸‹æ–‡ + ä¿æŒ Drawer æ‰“å¼€"æ—¶ä¿æŒé”
                // é˜²æ­¢è¯¯ç”¨ preserveConflictData å¯¼è‡´éšè—é”æ­»
                state.hasPendingConflict = keepDrawer && preserveConflictData;

                // å…³é—­ Drawerï¼ˆé™¤éæŒ‡å®šä¿æŒï¼‰
                if (!keepDrawer) {
                    closeConflictDrawer();
                }
            }

            function formatTimestamp(unixSeconds) {
                if (!unixSeconds) {
                    return "Unknown update time";
                }
                const date = new Date(unixSeconds * 1000);
                return date.toLocaleString();
            }

            function setEditorHint(checkboxCount, overrideText = "") {
                if (overrideText) {
                    ui.editorHint.textContent = overrideText;
                    return;
                }

                if (checkboxCount > 0) {
                    ui.editorHint.textContent = `å½“å‰æ–‡æ¡£æœ‰ ${checkboxCount} ä¸ªå¯åˆ‡æ¢ checkboxï¼Œç‚¹å‡»å›¾æ ‡å³å¯ä¿å­˜ï¼ˆå¿«æ·é”® 1-6ï¼‰`;
                } else {
                    ui.editorHint.textContent = "å½“å‰æ–‡æ¡£æ²¡æœ‰å¯åˆ‡æ¢ checkboxï¼ˆæ”¯æŒ - [ ] / * [ ] / + [ ]ï¼‰";
                }
            }

            function setRefreshMetaLabel(label) {
                ui.refreshMeta.textContent = label;
            }

            function markFileListRefreshed() {
                setRefreshMetaLabel("å·²åˆ·æ–° " + new Date().toLocaleTimeString());
            }

            function splitContentLines(content) {
                const normalized = String(content || "").replace(/\r\n/g, "\n");
                if (!normalized) {
                    return [];
                }
                const lines = normalized.split("\n");
                if (normalized.endsWith("\n")) {
                    lines.pop();
                }
                return lines;
            }

            /**
             * HTML è½¬ä¹‰å·¥å…·å‡½æ•°ï¼ˆç‹¬ç«‹å®šä¹‰ï¼Œå¤ç”¨ç°æœ‰æ¨¡å¼ï¼‰
             */
            function escapeHtml(value) {
                return String(value ?? "")
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#39;");
            }

            function parseCheckboxLine(line) {
                const match = /^(\s*[-*+]\s*\[)([ /xX\-!?])(\])(.*)$/.exec(line);
                if (!match) {
                    return null;
                }
                return {
                    status: match[2].toLowerCase(),
                    suffixText: match[4] || ""
                };
            }

            function getNextPrimaryStatus(currentStatus) {
                if (currentStatus === " ") {
                    return "/";
                }
                if (currentStatus === "/") {
                    return "x";
                }
                return " ";
            }

            function normalizeCheckboxState(statusChar) {
                return checkboxStateLookup.get(statusChar) || checkboxStateLookup.get(" ");
            }

            function hideCheckboxMenu() {
                ui.checkboxMenu.classList.remove("open");
                ui.checkboxMenu.style.left = "-9999px";
                ui.checkboxMenu.style.top = "-9999px";
                state.menuTargetLine = null;
            }

            function positionCheckboxMenu(clientX, clientY) {
                const menuRect = ui.checkboxMenu.getBoundingClientRect();
                const viewportPadding = 12;
                const maxLeft = window.innerWidth - menuRect.width - viewportPadding;
                const maxTop = window.innerHeight - menuRect.height - viewportPadding;
                const left = Math.max(viewportPadding, Math.min(clientX, maxLeft));
                const top = Math.max(viewportPadding, Math.min(clientY, maxTop));
                ui.checkboxMenu.style.left = `${left}px`;
                ui.checkboxMenu.style.top = `${top}px`;
            }

            function showCheckboxMenu(clientX, clientY, lineIndex) {
                state.menuTargetLine = lineIndex;
                ui.checkboxMenu.classList.add("open");
                positionCheckboxMenu(clientX, clientY);
            }

            function buildCheckboxMenu() {
                const fragment = document.createDocumentFragment();
                checkboxStateMeta.forEach((meta) => {
                    const item = document.createElement("button");
                    item.type = "button";
                    item.className = "checkbox-menu-item";
                    item.dataset.status = meta.char;
                    item.setAttribute("role", "menuitem");
                    item.innerHTML = `
                        <span class="checkbox-menu-icon">${meta.icon}</span>
                        <span>${meta.label}</span>
                        <span class="checkbox-menu-key">${meta.key}</span>
                    `;
                    fragment.appendChild(item);
                });
                ui.checkboxMenu.replaceChildren(fragment);
            }

            function renderFileList() {
                ui.docList.replaceChildren();

                if (!state.files.length) {
                    const emptyItem = document.createElement("li");
                    emptyItem.className = "empty";
                    emptyItem.textContent = "No markdown files in .claude.";
                    ui.docList.appendChild(emptyItem);
                    return;
                }

                const fragment = document.createDocumentFragment();

                state.files.forEach((file) => {
                    const isActive = file.path === state.activePath;
                    const activeClass = isActive ? "doc-item active" : "doc-item";

                    const listItem = document.createElement("li");
                    const openButton = document.createElement("button");
                    openButton.type = "button";
                    openButton.className = activeClass;
                    openButton.dataset.path = file.path;
                    openButton.setAttribute("aria-label", "Open " + file.path);

                    const name = document.createElement("p");
                    name.className = "doc-name";
                    name.textContent = file.name + ".md";

                    const meta = document.createElement("p");
                    meta.className = "doc-meta";
                    meta.textContent = formatTimestamp(file.mtime);

                    openButton.appendChild(name);
                    openButton.appendChild(meta);
                    openButton.addEventListener("click", () => {
                        void loadFile(file.path);
                    });

                    listItem.appendChild(openButton);
                    fragment.appendChild(listItem);
                });

                ui.docList.appendChild(fragment);
            }

            function renderFileContent(content) {
                ui.editor.replaceChildren();

                const lines = splitContentLines(content);
                if (!lines.length) {
                    const emptyText = document.createElement("p");
                    emptyText.className = "empty";
                    emptyText.textContent = "The selected file is empty.";
                    ui.editor.appendChild(emptyText);
                    setEditorHint(0, "å½“å‰æ–‡æ¡£ä¸ºç©ºï¼Œä¸åŒ…å«å¯åˆ‡æ¢ checkbox");
                    return;
                }

                const fragment = document.createDocumentFragment();
                let checkboxCount = 0;

                lines.forEach((line, lineIndex) => {
                    const checkboxData = parseCheckboxLine(line);
                    const row = document.createElement("div");
                    row.className = "editor-line";
                    row.dataset.lineIndex = String(lineIndex);

                    if (!checkboxData) {
                        row.textContent = line || " ";
                        fragment.appendChild(row);
                        return;
                    }

                    checkboxCount += 1;
                    const statusMeta = normalizeCheckboxState(checkboxData.status);
                    row.classList.add("checkbox-line");

                    const checkboxButton = document.createElement("button");
                    checkboxButton.type = "button";
                    checkboxButton.className = `checkbox-btn ${statusMeta.css}`;
                    checkboxButton.dataset.lineIndex = String(lineIndex);
                    checkboxButton.dataset.status = checkboxData.status;
                    checkboxButton.dataset.role = "checkbox-control";
                    checkboxButton.setAttribute("aria-label", `Checkbox line ${lineIndex + 1}: ${statusMeta.label}`);
                    checkboxButton.textContent = statusMeta.icon;

                    checkboxButton.addEventListener("focus", () => {
                        state.selectedCheckboxLine = lineIndex;
                    });

                    checkboxButton.addEventListener("click", () => {
                        state.selectedCheckboxLine = lineIndex;
                        hideCheckboxMenu();
                        void updateCheckboxStatus(lineIndex, getNextPrimaryStatus(checkboxData.status));
                    });

                    checkboxButton.addEventListener("contextmenu", (event) => {
                        event.preventDefault();
                        state.selectedCheckboxLine = lineIndex;
                        showCheckboxMenu(event.clientX, event.clientY, lineIndex);
                    });

                    const text = document.createElement("span");
                    text.className = "checkbox-text";
                    text.textContent = checkboxData.suffixText || "";

                    row.appendChild(checkboxButton);
                    row.appendChild(text);
                    fragment.appendChild(row);
                });

                ui.editor.appendChild(fragment);
                if (checkboxCount === 0) {
                    state.selectedCheckboxLine = null;
                }
                setEditorHint(checkboxCount);
            }

            async function updateCheckboxStatus(lineIndex, nextStatus) {
                if (!state.activePath) {
                    return;
                }

                // å¹¶å‘æ§åˆ¶ï¼šå†²çªå¤„ç†ä¸­æˆ–æ­£åœ¨ä¿å­˜æ—¶é˜»æ­¢æ“ä½œ
                // [ä¿®æ­£1] æ·»åŠ  hasPendingConflict æ£€æŸ¥ï¼Œé˜²æ­¢å†²çªå¼¹çª—æ‰“å¼€æ—¶ç»§ç»­ç¼–è¾‘
                if (state.isSaving || state.isResolvingConflict || state.hasPendingConflict) {
                    setStatus("è¯·ç­‰å¾…å½“å‰æ“ä½œå®Œæˆ", "warn");
                    return;
                }

                // æ„å»ºç¨³å¥è¡Œç­¾åï¼ˆç”¨äºæœåŠ¡å™¨å†…å®¹åŒ¹é…ï¼‰
                // å…³é”®ï¼šä½¿ç”¨é‡å»ºçš„åŸå§‹ markdown è¡Œï¼Œè€ŒéåŒ…å« UI å›¾æ ‡çš„ DOM æ–‡æœ¬
                // [ä¿®æ­£2] ä¿å­˜å®Œæ•´åŸå§‹è¡Œå‰ç¼€ï¼ˆbullet + indentï¼‰ï¼Œä¸ç¡¬ç¼–ç  "-"
                const lineElement = document.querySelector(`.editor-line[data-line-index="${lineIndex}"]`);
                let originalMarkdownLine = "";
                let originalLinePrefix = "";  // [æ–°å¢] ä¿å­˜åŸå§‹å‰ç¼€ï¼ˆbullet + indentï¼‰

                if (lineElement) {
                    const checkboxBtn = lineElement.querySelector('.checkbox-btn');
                    const textSpan = lineElement.querySelector('.checkbox-text');

                    if (checkboxBtn && textSpan) {
                        // [ä¿®æ­£2] æå–å¹¶ä¿å­˜å®Œæ•´è¡Œå‰ç¼€ï¼ˆåŒ¹é…ç°æœ‰ checkbox è¡Œæ ¼å¼ï¼‰
                        // æ”¯æŒ: "- [ ]", "* [ ]", "+ [ ]", ä»¥åŠç¼©è¿›å˜ä½“
                        const lineText = lineElement.textContent || "";
                        const checkboxMatch = lineText.match(/^(\s*[-*+]\s*\[)([ /xX\-!?])(\])(.*)$/);

                        if (checkboxMatch) {
                            originalLinePrefix = checkboxMatch[1];  // "- [", "* [", "+ [", æˆ–å¸¦ç¼©è¿›
                            const currentStatus = checkboxBtn.dataset.status || " ";
                            const suffixText = textSpan.textContent || "";
                            originalMarkdownLine = `${originalLinePrefix}${currentStatus}]${suffixText}`;
                        }
                    }
                }

                // æ„å»ºå”¯ä¸€è¯·æ±‚ID
                const requestId = ++state.lastRequestId;
                state.lastRequestTimestamp = Date.now();
                state.isSaving = true;

                setStatus("ä¿å­˜ä¸­...", "info");

                try {
                    const payload = {
                        file_path: state.activePath,
                        line_index: lineIndex,
                        new_status: nextStatus,
                        base_rev: state.activeRev,
                        base_mtime: state.activeMtime
                    };

                    const result = await fetchJson("/api/checkbox", {
                        method: "PATCH",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload)
                    });

                    state.activeRev = result.rev;
                    state.activeMtime = result.mtime;
                    await loadFile(state.activePath, false);
                    setStatus("å·²ä¿å­˜", "success");

                } catch (error) {
                    if (error && error.status === 409) {
                        // ä¿å­˜å†²çªä¸Šä¸‹æ–‡
                        state.pendingCheckboxUpdate = {
                            lineIndex,
                            newStatus: nextStatus,
                            originalMarkdownLine,
                            originalLinePrefix,  // [ä¿®æ­£2] ä¿å­˜åŸå§‹å‰ç¼€ç”¨äºç¨³å¥å®šä½
                            requestId,
                            targetLine: `checkbox-line-${lineIndex}`
                        };

                        state.conflictRetryCount = 0;

                        // è¿›å…¥å†²çªå¤„ç†æµç¨‹
                        await handleConflict(error.payload, requestId);
                    } else {
                        setStatus("ä¿å­˜å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•", "error");
                    }
                } finally {
                    // [ä¿®æ­£1] ä½¿ç”¨ hasPendingConflict åˆ¤æ–­æ˜¯å¦ä¿æŒé”å®š
                    // ä»…åœ¨æ— å¾…å¤„ç†å†²çªæ—¶é‡ç½® isSaving
                    if (!state.hasPendingConflict) {
                        state.isSaving = false;
                    }
                }
            }

            async function handleConflict(conflictPayload, requestId) {
                // è¯·æ±‚è¿‡æœŸæ£€æŸ¥
                if (requestId !== state.lastRequestId) {
                    setStatus("å†²çªå¤„ç†å·²è¿‡æœŸ", "warn");
                    // [P1 ä¿®å¤] ä½¿ç”¨ clearConflictState ç»Ÿä¸€æ¸…ç†
                    clearConflictState();
                    return;
                }

                state.isResolvingConflict = true;
                state.hasPendingConflict = true;  // [ä¿®æ­£1] ä¿æŒé”å®šç›´åˆ° merge/discard å®Œæˆ
                setStatus("æ£€æµ‹åˆ°å†²çªï¼Œæ­£åœ¨è·å–æœ€æ–°ç‰ˆæœ¬...", "warn");

                try {
                    // æ­¥éª¤1: è·å–æœåŠ¡å™¨æœ€æ–°å†…å®¹
                    // æ³¨æ„ï¼šä½¿ç”¨ path æŸ¥è¯¢å‚æ•°ï¼ˆåç«¯è¦æ±‚ï¼‰
                    const serverFile = await fetchJson("/api/file?path=" + encodeURIComponent(state.activePath));

                    // æ­¥éª¤2: æ ¡éªŒ rev ç¡®ä¿æ•°æ®ä¸€è‡´æ€§
                    if (serverFile.rev !== conflictPayload.current_rev) {
                        throw new Error("æœåŠ¡å™¨ç‰ˆæœ¬åœ¨è·å–è¿‡ç¨‹ä¸­å·²æ›´æ–°");
                    }

                    // æ­¥éª¤3: ä¿å­˜å®Œæ•´å†²çªä¸Šä¸‹æ–‡ï¼Œ**å›ºåŒ–æ–‡ä»¶è·¯å¾„**
                    state.conflictData = {
                        serverRev: serverFile.rev,
                        serverMtime: serverFile.mtime,
                        serverContent: serverFile.content,
                        localRev: state.activeRev,
                        localMtime: state.activeMtime,
                        pendingChange: state.pendingCheckboxUpdate,
                        conflictDetectedAt: Date.now(),
                        filePath: state.activePath  // å›ºåŒ–è·¯å¾„ï¼Œé˜²æ­¢æ–‡æ¡£åˆ‡æ¢å¯¼è‡´é”™å†™
                    };

                    // æ­¥éª¤4: æ˜¾ç¤ºå†²çªå¼¹çª—ï¼ˆç‹¬ç«‹ Drawerï¼‰
                    showConflictDrawer();
                    setStatus("æ£€æµ‹åˆ°å†²çª", "conflict");

                    // [P1 ä¿®å¤] ä¸é‡ç½®çŠ¶æ€ï¼Œä¿æŒé”å®šç›´åˆ°ç”¨æˆ·å†³ç­–
                    // isResolvingConflict = true; hasPendingConflict = true;

                } catch (fetchError) {
                    console.error("å†²çªå¤„ç†å¤±è´¥:", fetchError);

                    // é‡è¯•é€»è¾‘ï¼ˆæœ€å¤š3æ¬¡ï¼ŒæŒ‡æ•°é€€é¿ï¼‰
                    if (state.conflictRetryCount < 3) {
                        state.conflictRetryCount++;
                        const delay = Math.pow(2, state.conflictRetryCount) * 500;

                        setStatus(`è·å–å¤±è´¥ï¼Œ${delay/1000}ç§’åé‡è¯•...`, "warn");
                        await new Promise(resolve => setTimeout(resolve, delay));

                        await handleConflict(conflictPayload, requestId);
                    } else {
                        setStatus("æ— æ³•è·å–æœ€æ–°ç‰ˆæœ¬ï¼Œè¯·æ‰‹åŠ¨åˆ·æ–°", "error");
                        // [P1 ä¿®å¤] ä½¿ç”¨ clearConflictState ç»Ÿä¸€æ¸…ç†
                        clearConflictState();
                    }
                }
            }

            /**
             * æ˜¾ç¤ºå†²çªè§£å†³ Drawerï¼ˆç‹¬ç«‹ç³»ç»Ÿï¼Œä¸å½±å“ç°æœ‰çŠ¶æ€æ è¯¦æƒ…ï¼‰
             */
            function showConflictDrawer() {
                const conflict = state.conflictData;
                if (!conflict) {
                    setStatus("æ— å†²çªæ•°æ®", "error");
                    return;
                }

                const pending = conflict.pendingChange;
                const currentStatusLabel = getNextStatusLabel(pending.newStatus);

                // æ„å»ºå†²çªè¯¦æƒ…å†…å®¹
                const contentHtml = `
                    <div class="conflict-drawer">
                        <table class="conflict-table">
                            <tr><td class="conflict-label">æœåŠ¡å™¨ç‰ˆæœ¬æ—¶é—´</td><td class="conflict-value">${escapeHtml(formatTimestamp(conflict.serverMtime))}</td></tr>
                            <tr><td class="conflict-label">ä½ çš„ç‰ˆæœ¬æ—¶é—´</td><td class="conflict-value">${escapeHtml(formatTimestamp(conflict.localMtime))}</td></tr>
                            <tr><td class="conflict-label">ä½ çš„ä¿®æ”¹</td><td class="conflict-value">è¡Œ ${pending.lineIndex + 1} â†’ ${escapeHtml(currentStatusLabel)}</td></tr>
                        </table>
                        <p style="color: #6b7280; font-size: 13px; margin-top: 16px;">é€‰æ‹©è§£å†³æ–¹å¼ï¼š</p>
                        <div class="conflict-actions">
                            <button type="button" class="conflict-action-btn primary" id="conflict-merge-btn">
                                é€è¡Œä¿ç•™æˆ‘çš„çŠ¶æ€å˜æ›´
                            </button>
                            <button type="button" class="conflict-action-btn secondary" id="conflict-discard-btn">
                                æ”¾å¼ƒæˆ‘çš„ä¿®æ”¹ï¼ŒåŠ è½½æœ€æ–°ç‰ˆæœ¬
                            </button>
                        </div>
                    </div>
                `;

                document.getElementById("conflict-drawer-content").innerHTML = contentHtml;
                document.getElementById("conflict-drawer").classList.add("open");
                document.getElementById("conflict-drawer").setAttribute("aria-hidden", "false");
            }

            /**
             * å…³é—­å†²çª Drawer
             */
            function closeConflictDrawer() {
                document.getElementById("conflict-drawer").classList.remove("open");
                document.getElementById("conflict-drawer").setAttribute("aria-hidden", "true");
            }

            /**
             * è·å–çŠ¶æ€æ ‡ç­¾æ–‡æœ¬
             */
            function getNextStatusLabel(statusChar) {
                const meta = checkboxStateLookup.get(statusChar);
                return meta ? meta.label : statusChar;
            }

            /**
             * ç¨³å¥åˆå¹¶ç”¨æˆ·çš„ checkbox çŠ¶æ€å˜æ›´
             */
            async function mergeCheckboxStatus() {
                const conflict = state.conflictData;
                if (!conflict) {
                    setStatus("æ— å†²çªæ•°æ®", "error");
                    return;
                }

                state.isResolvingConflict = true;
                setStatus("æ­£åœ¨ç¨³å¥åˆå¹¶çŠ¶æ€å˜æ›´...", "info");

                // ç¦ç”¨æŒ‰é’®é˜²æ­¢é‡å¤ç‚¹å‡»
                document.getElementById("conflict-merge-btn").disabled = true;
                document.getElementById("conflict-discard-btn").disabled = true;

                try {
                    // 1. è§£ææœåŠ¡å™¨å†…å®¹ï¼ˆå¤ç”¨ç°æœ‰ splitContentLinesï¼‰
                    const serverLines = splitContentLines(conflict.serverContent);
                    const pending = conflict.pendingChange;

                    // 2. ç¨³å¥å®šä½ç›®æ ‡è¡Œ
                    // [ä¿®æ­£2] ä¼ å…¥ä¿å­˜çš„åŸå§‹å‰ç¼€ä»¥æ”¯æŒç¨³å¥åŒ¹é…
                    const targetLineIndex = findTargetLineInContent(
                        serverLines,
                        pending.lineIndex,
                        pending.originalMarkdownLine,
                        pending.originalLinePrefix,  // æ–°å¢ï¼šåŸå§‹å‰ç¼€ç”¨äºç²¾ç¡®åŒ¹é…
                        3
                    );

                    if (targetLineIndex === -1) {
                        setStatus("ç›®æ ‡è¡Œå·²è¢«åˆ é™¤æˆ–é‡å†™ï¼Œæ— æ³•åˆå¹¶", "warn");
                        await discardAndReload();
                        return;
                    }

                    // 3. æ£€æŸ¥ç›®æ ‡è¡Œæ˜¯å¦ä»ä¸º checkbox
                    const serverLine = serverLines[targetLineIndex] || "";
                    const checkboxPattern = /^(\s*[-*+]\s*\[)([ /xX\-!?])(\])(.*)$/;
                    const match = serverLine.match(checkboxPattern);

                    if (!match) {
                        setStatus("ç›®æ ‡è¡Œå·²è¢«ä¿®æ”¹ä¸ºécheckboxï¼Œæ— æ³•åˆå¹¶", "warn");
                        await discardAndReload();
                        return;
                    }

                    // 4. å‘é€åˆå¹¶è¯·æ±‚ï¼ˆä½¿ç”¨å›ºåŒ–çš„æ–‡ä»¶è·¯å¾„ï¼‰
                    const payload = {
                        file_path: conflict.filePath,
                        line_index: targetLineIndex,
                        new_status: pending.newStatus,
                        base_rev: conflict.serverRev,
                        base_mtime: conflict.serverMtime
                    };

                    const result = await fetchJson("/api/checkbox", {
                        method: "PATCH",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload)
                    });

                    // 5. æˆåŠŸåˆå¹¶ï¼šæ¸…ç†çŠ¶æ€
                    state.activeRev = result.rev;
                    state.activeMtime = result.mtime;

                    // 6. é‡æ–°åŠ è½½æ–‡ä»¶ï¼ˆä½¿ç”¨å›ºåŒ–çš„è·¯å¾„ï¼‰
                    await loadFile(conflict.filePath, false);

                    // [P1 ä¿®å¤] ä½¿ç”¨ clearConflictState ç»Ÿä¸€æ¸…ç†
                    clearConflictState({ keepDrawer: false });
                    setStatus("çŠ¶æ€å˜æ›´å·²ç¨³å¥åˆå¹¶", "success");

                } catch (error) {
                    console.error("åˆå¹¶å¤±è´¥:", error);

                    if (error && error.status === 409) {
                        // äºŒæ¬¡å†²çª
                        state.conflictRetryCount++;

                        if (state.conflictRetryCount <= 3) {
                            const delay = Math.pow(2, state.conflictRetryCount) * 1000;
                            setStatus(`å†æ¬¡æ£€æµ‹åˆ°å†²çªï¼Œ${delay/1000}ç§’åé‡è¯•...`, "warn");

                            await new Promise(resolve => setTimeout(resolve, delay));
                            await handleConflict(error.payload, state.lastRequestId);
                        } else {
                            setStatus("å¤šæ¬¡åˆå¹¶å¤±è´¥ï¼Œå·²åŠ è½½æœ€æ–°ç‰ˆæœ¬", "warn");
                            await discardAndReload();
                        }
                    } else {
                        setStatus(`åˆå¹¶å¤±è´¥: ${error.message || "æœªçŸ¥é”™è¯¯"}ï¼Œè¯·é‡è¯•æˆ–æ”¾å¼ƒä¿®æ”¹`, "error");
                        // [P1 ä¿®å¤] ä¿æŒ Drawer ä¸å†²çªä¸Šä¸‹æ–‡ï¼Œå…è®¸ç”¨æˆ·é‡è¯•
                        clearConflictState({ keepDrawer: true, preserveConflictData: true });
                        // æ¢å¤æŒ‰é’®çŠ¶æ€
                        document.getElementById("conflict-merge-btn").disabled = false;
                        document.getElementById("conflict-discard-btn").disabled = false;
                    }
                }
            }

            /**
             * æ”¾å¼ƒä¿®æ”¹å¹¶åŠ è½½æœ€æ–°ç‰ˆæœ¬
             */
            async function discardAndReload() {
                const conflict = state.conflictData;
                if (!conflict) {
                    setStatus("æ— å†²çªæ•°æ®", "error");
                    return;
                }

                state.isResolvingConflict = true;
                setStatus("æ­£åœ¨åŠ è½½æœ€æ–°ç‰ˆæœ¬...", "info");

                try {
                    // ä½¿ç”¨å›ºåŒ–çš„æ–‡ä»¶è·¯å¾„
                    const targetPath = conflict.filePath;

                    // ç›´æ¥ä½¿ç”¨å·²è·å–çš„æœåŠ¡å™¨å†…å®¹æ¸²æŸ“
                    state.activeRev = conflict.serverRev;
                    state.activeMtime = conflict.serverMtime;
                    state.activePath = targetPath;  // å…³é”®ï¼šæ¢å¤ activePath

                    // æ¸²æŸ“æœåŠ¡å™¨å†…å®¹
                    renderFileContent(conflict.serverContent || "");

                    // æ›´æ–° UI æ˜¾ç¤ºè·¯å¾„
                    ui.activePath.textContent = targetPath;
                    ui.activeTime.textContent = formatTimestamp(conflict.serverMtime);

                    // [ä¿®æ­£4] åˆ·æ–°æ–‡æ¡£åˆ—è¡¨ä»¥ä¿æŒå·¦ä¾§æ¿€æ´»æ€ä¸€è‡´
                    renderFileList();

                    // [P1 ä¿®å¤] ä½¿ç”¨ clearConflictState ç»Ÿä¸€æ¸…ç†
                    clearConflictState({ keepDrawer: false });
                    setStatus("å·²åŠ è½½æœ€æ–°ç‰ˆæœ¬", "success");

                } catch (error) {
                    console.error("åŠ è½½æœ€æ–°ç‰ˆæœ¬å¤±è´¥:", error);
                    setStatus(`åŠ è½½å¤±è´¥: ${error.message || "æœªçŸ¥é”™è¯¯"}ï¼Œè¯·é‡è¯•æˆ–ç»§ç»­åˆå¹¶`, "error");
                    // [P1 ä¿®å¤] ä¿æŒ Drawer ä¸å†²çªä¸Šä¸‹æ–‡ï¼Œå…è®¸ç”¨æˆ·é‡è¯•
                    clearConflictState({ keepDrawer: true, preserveConflictData: true });
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    document.getElementById("conflict-merge-btn").disabled = false;
                    document.getElementById("conflict-discard-btn").disabled = false;
                }
            }

            /**
             * ç¨³å¥è¡Œå®šä½ç®—æ³•ï¼ˆäº”çº§ç­–ç•¥ + P2 å‡çº§ï¼‰
             * [ä¿®æ­£2] æ–°å¢ originalLinePrefix å‚æ•°ï¼Œç”¨äºç²¾ç¡®å‰ç¼€åŒ¹é…
             * [P2 å‡çº§] ä½¿ç”¨ Jaccard ç›¸ä¼¼åº¦æ›¿ä»£å­—ç¬¦é›†åˆç›¸ä¼¼åº¦
             */
            function findTargetLineInContent(serverLines, originalIndex, originalText, originalLinePrefix, searchRadius = 3) {
                // ç­–ç•¥0: ç²¾ç¡®å‰ç¼€+æ–‡æœ¬åŒ¹é…ï¼ˆæœ€å¯é ï¼‰
                if (originalIndex < serverLines.length) {
                    const line = serverLines[originalIndex];
                    // ä½¿ç”¨ä¿å­˜çš„åŸå§‹å‰ç¼€è¿›è¡Œç²¾ç¡®åŒ¹é…
                    if (line && line.startsWith(originalLinePrefix || "- [")) {
                        const suffixMatch = line.substring((originalLinePrefix || "- [").length).includes(originalText.substring(0, 50));
                        if (suffixMatch) {
                            return originalIndex;
                        }
                    }
                }

                // ç­–ç•¥1: åŸå§‹ä½ç½®ç›´æ¥åŒ¹é…
                if (originalIndex < serverLines.length) {
                    const line = serverLines[originalIndex];
                    if (line && line.includes(originalText.substring(0, 30))) {
                        return originalIndex;
                    }
                }

                // ç­–ç•¥2: æ–‡æœ¬ç­¾ååŒ¹é…
                const originalFingerprint = createLineFingerprint(originalText);
                for (let i = 0; i < serverLines.length; i++) {
                    const lineFingerprint = createLineFingerprint(serverLines[i]);
                    if (lineFingerprint === originalFingerprint) {
                        return i;
                    }
                }

                // ç­–ç•¥3: é‚»åŸŸæœç´¢
                const start = Math.max(0, originalIndex - searchRadius);
                const end = Math.min(serverLines.length - 1, originalIndex + searchRadius);
                for (let i = start; i <= end; i++) {
                    const line = serverLines[i];
                    const checkboxPattern = /^(\s*[-*+]\s*\[)([ /xX\-!?])(\])(.*)$/;
                    if (checkboxPattern.test(line) && line.includes(originalText.substring(0, 50))) {
                        return i;
                    }
                }

                // ç­–ç•¥4: å…¨æ–‡æ¡£èŒƒå›´æœç´¢ç›¸ä¼¼è¡Œ
                const similarityThreshold = 0.8;
                let bestMatch = -1;
                let bestScore = 0;

                for (let i = 0; i < serverLines.length; i++) {
                    const similarity = calculateTextSimilarity(originalText, serverLines[i]);
                    if (similarity > bestScore && similarity >= similarityThreshold) {
                        bestScore = similarity;
                        bestMatch = i;
                    }
                }

                return bestMatch;
            }

            function createLineFingerprint(text) {
                const normalized = text.trim().replace(/\s+/g, ' ').substring(0, 50);
                let hash = 0;
                for (let i = 0; i < normalized.length; i++) {
                    hash = ((hash << 5) - hash) + normalized.charCodeAt(i);
                    hash |= 0;
                }
                return hash.toString(16);
            }

            /**
             * [P2 å‡çº§] æ–‡æœ¬ç›¸ä¼¼åº¦ç®—æ³• - token bigram Jaccard
             * å¯¹é¡ºåºæ•æ„Ÿï¼Œæ¯”å­—ç¬¦é›†åˆç›¸ä¼¼åº¦æ›´å¯é ï¼Œä¸”å…¼å®¹ä¸­è‹±æ–‡æ··åˆæ–‡æœ¬
             */
            function calculateTextSimilarity(text1, text2) {
                if (!text1 || !text2) return 0;

                // è¯çº§ tokenï¼ˆè‹±æ–‡å•è¯ + æ•°å­— + å•ä¸ªä¸­æ–‡å­—ç¬¦ï¼‰
                const tokenPattern = /[a-z0-9]+|[\u4e00-\u9fa5]/gi;
                const tokens1 = (text1.toLowerCase().match(tokenPattern) || []);
                const tokens2 = (text2.toLowerCase().match(tokenPattern) || []);

                if (tokens1.length === 0 || tokens2.length === 0) return 0;

                // ä½¿ç”¨ bigram è®©é¡ºåºä¿¡æ¯è¿›å…¥ç›¸ä¼¼åº¦è®¡ç®—
                const grams1 = tokens1.length > 1
                    ? tokens1.slice(0, -1).map((t, i) => `${t} ${tokens1[i + 1]}`)
                    : tokens1;
                const grams2 = tokens2.length > 1
                    ? tokens2.slice(0, -1).map((t, i) => `${t} ${tokens2[i + 1]}`)
                    : tokens2;

                // Jaccard ç›¸ä¼¼åº¦ = |A âˆ© B| / |A âˆª B|
                const set1 = new Set(grams1);
                const set2 = new Set(grams2);
                const intersection = new Set([...set1].filter(x => set2.has(x)));
                const union = new Set([...set1, ...set2]);

                return intersection.size / union.size;
            }

            async function fetchJson(url, options = {}) {
                const response = await fetch(url, options);
                let payload = {};

                try {
                    payload = await response.json();
                } catch (_error) {
                    payload = {};
                }

                if (!response.ok) {
                    const message = payload.error || ("Request failed with " + response.status);
                    const error = new Error(message);
                    error.status = response.status;
                    error.payload = payload;
                    throw error;
                }

                return payload;
            }

            async function loadFiles(preserveSelection = true, trigger = "auto") {
                if (trigger === "manual") {
                    setStatus("æ­£åœ¨åˆ·æ–°æ–‡æ¡£åˆ—è¡¨...", "info");
                } else {
                    setStatus("æ­£åœ¨åŠ è½½æ–‡æ¡£åˆ—è¡¨...", "info");
                }

                try {
                    const files = await fetchJson("/api/files");
                    state.files = Array.isArray(files) ? files : [];
                    markFileListRefreshed();

                    if (!state.files.length) {
                        state.activePath = null;
                        ui.activePath.textContent = "No document selected";
                        ui.activeTime.textContent = "No files available in .claude/";
                        renderFileList();
                        renderFileContent("");
                        setEditorHint(0, "å½“å‰æ²¡æœ‰å¯ç¼–è¾‘æ–‡æ¡£");
                        setStatus("æœªæ‰¾åˆ°å¯ç”¨æ–‡æ¡£", "warn");
                        return;
                    }

                    if (!preserveSelection || !state.activePath) {
                        state.activePath = state.files[0].path;
                    } else if (!state.files.some((file) => file.path === state.activePath)) {
                        state.activePath = state.files[0].path;
                    }

                    renderFileList();
                    await loadFile(state.activePath, false);
                    if (trigger === "manual") {
                        setStatus("æ–‡æ¡£åˆ—è¡¨å·²åˆ·æ–°", "success");
                    } else {
                        setStatus("å·²å°±ç»ª", "success");
                    }
                } catch (error) {
                    setStatus("åŠ è½½æ–‡æ¡£åˆ—è¡¨å¤±è´¥", "error");
                    setRefreshMetaLabel("åˆ·æ–°å¤±è´¥");
                    ui.activePath.textContent = "Error";
                    ui.activeTime.textContent = String(error.message || error);
                    ui.editor.textContent = "Unable to load file list.";
                    setEditorHint(0, "åŠ è½½å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•");
                }
            }

            async function loadFile(path, updateStatus = true) {
                if (!path) {
                    return;
                }

                if (updateStatus) {
                    setStatus("æ­£åœ¨åŠ è½½ " + path + "...", "info");
                }

                try {
                    const previousPath = state.activePath;
                    const file = await fetchJson("/api/file?path=" + encodeURIComponent(path));
                    state.activePath = file.path;
                    state.activeRev = file.rev;
                    state.activeMtime = file.mtime;
                    if (previousPath !== file.path) {
                        state.selectedCheckboxLine = null;
                    }
                    hideCheckboxMenu();

                    ui.activePath.textContent = file.path;
                    ui.activeTime.textContent = "Last updated: " + formatTimestamp(file.mtime);
                    renderFileContent(file.content || "");
                    renderFileList();
                    if (updateStatus) {
                        setStatus("å·²å°±ç»ª", "success");
                    }
                } catch (error) {
                    setStatus("åŠ è½½æ–‡æ¡£å¤±è´¥", "error");
                    ui.activeTime.textContent = String(error.message || error);
                    setEditorHint(0, "åŠ è½½å¤±è´¥ï¼Œæ— æ³•è§£æ checkbox");
                }
            }

            ui.refreshFilesBtn.addEventListener("click", () => {
                void loadFiles(true, "manual");
            });

            window.addEventListener("keydown", (event) => {
                if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === "r") {
                    event.preventDefault();
                    void loadFiles(true, "manual");
                    return;
                }

                if (event.key === "Escape") {
                    hideCheckboxMenu();
                    return;
                }

                if (event.ctrlKey || event.metaKey || event.altKey) {
                    return;
                }

                const mappedStatus = keyboardStatusMap[event.key];
                if (!mappedStatus) {
                    return;
                }

                if (state.selectedCheckboxLine === null) {
                    setStatus("è¯·å…ˆç‚¹å‡»ä¸€ä¸ª checkbox", "warn");
                    return;
                }

                event.preventDefault();
                hideCheckboxMenu();
                void updateCheckboxStatus(state.selectedCheckboxLine, mappedStatus);
            });

            void loadFiles(false, "initial");

            // ========== Status Bar State Management ==========
            const statusBarState = {
                summary: null,
                activePanel: null,
                pollingInterval: null
            };

            // ========== Load Status Summary ==========
            async function loadStatusSummary() {
                try {
                    const summary = await fetchJson("/api/status-summary");
                    statusBarState.summary = summary;
                    renderStatusBar(summary);
                    return true;
                } catch (error) {
                    console.error("Failed to load status summary:", error);
                    renderStatusBarFallback();
                    setStatus("Failed to load status", "error");
                    return false;
                }
            }

            // ========== Render Status Bar ==========
            function renderStatusBar(summary) {
                const progress = summary.progress || { completed: 0, total: 0, percentage: 0 };
                const nextAction = summary.next_action || { type: "none", feature_id: null, feature_name: "-" };
                const planHealth = summary.plan_health || { status: "N/A" };
                const riskBlocker = summary.risk_blocker || { has_risk: false, message: "-" };
                const recentSnapshot = summary.recent_snapshot || { relative_time: "-" };

                // 1. Progress
                const progressValue = document.getElementById("progress-value");
                progressValue.textContent = `${progress.completed}/${progress.total} (${progress.percentage}%)`;

                // 2. Next Action
                const nextValue = document.getElementById("next-value");
                if (nextAction.type === "feature" && nextAction.feature_id != null) {
                    nextValue.textContent = `#${nextAction.feature_id}`;
                    nextValue.title = nextAction.feature_name || "";
                } else {
                    nextValue.textContent = nextAction.feature_name || "-";
                    nextValue.title = "";
                }

                // 3. Plan Health
                const planValue = document.getElementById("plan-value");
                planValue.textContent = planHealth.status;
                planValue.className = "status-value";
                if (planHealth.status === "OK") {
                    planValue.classList.add("ok");
                } else if (planHealth.status === "WARN") {
                    planValue.classList.add("warn");
                } else if (planHealth.status === "INVALID") {
                    planValue.classList.add("error");
                }

                // 4. Risk Blocker
                const riskValue = document.getElementById("risk-value");
                riskValue.textContent = riskBlocker.message;
                riskValue.className = "status-value";
                if (riskBlocker.has_risk) {
                    riskValue.classList.add("error");
                }

                // 5. Recent Snapshot
                const snapshotValue = document.getElementById("snapshot-value");
                snapshotValue.textContent = recentSnapshot.relative_time;
            }

            function renderStatusBarFallback() {
                const progressValue = document.getElementById("progress-value");
                const nextValue = document.getElementById("next-value");
                const planValue = document.getElementById("plan-value");
                const riskValue = document.getElementById("risk-value");
                const snapshotValue = document.getElementById("snapshot-value");

                progressValue.textContent = "-/-";
                nextValue.textContent = "-";
                nextValue.title = "";
                planValue.textContent = "-";
                planValue.className = "status-value";
                riskValue.textContent = "-";
                riskValue.className = "status-value";
                snapshotValue.textContent = "-";
            }

            // ========== Open Drawer ==========
            async function openDrawer(panelType) {
                statusBarState.activePanel = panelType;

                try {
                    const response = await fetchJson(`/api/status-detail?panel=${panelType}`);
                    renderDrawerContent(panelType, response);

                    document.getElementById("drawer-title").textContent = getPanelTitle(panelType);
                    document.getElementById("status-drawer").classList.add("open");
                } catch (error) {
                    console.error("Failed to load detail:", error);
                    setStatus("Failed to load detail", "error");
                }
            }

            // ========== Render Drawer Content ==========
            function renderDrawerContent(panelType, detail) {
                const content = document.getElementById("drawer-content");
                const escapeHtml = (value) => String(value ?? "")
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#39;");

                // Render summary
                let html = `<p class="drawer-summary">${escapeHtml(detail.summary)}</p>`;

                // Render sections
                detail.sections.forEach(section => {
                    html += renderSection(section);
                });

                // Render sources
                if (detail.sources && detail.sources.length > 0) {
                    html += '<div class="drawer-sources"><h4>æ•°æ®æ¥æº</h4>';
                    detail.sources.forEach(source => {
                        const lineInfo = source.line ? `:${source.line}` : '';
                        html += `<button class="source-btn" type="button" data-source-path="${escapeHtml(source.path)}">
                            <span class="source-icon">ğŸ“„</span>
                            <span class="source-label">${escapeHtml(source.label)}</span>
                            <span class="source-path">${escapeHtml(source.path)}${escapeHtml(lineInfo)}</span>
                        </button>`;
                    });
                    html += '</div>';
                }

                // Render actions
                if (detail.actions && detail.actions.length > 0) {
                    html += '<div class="drawer-actions"><h4>å»ºè®®æ“ä½œ</h4>';
                    detail.actions.forEach(action => {
                        if (action.type === 'copy') {
                            html += `<button class="action-btn" type="button" data-action-type="copy" data-command="${escapeHtml(action.command)}">
                                <span class="action-icon">ğŸ“‹</span>
                                <span class="action-label">${escapeHtml(action.label)}</span>
                                <code class="action-cmd">${escapeHtml(action.command)}</code>
                            </button>`;
                        } else if (action.type === 'link') {
                            html += `<button class="action-btn" type="button" data-action-type="link" data-command="${escapeHtml(action.command)}">
                                <span class="action-icon">ğŸ”—</span>
                                <span class="action-label">${escapeHtml(action.label)}</span>
                            </button>`;
                        }
                    });
                    html += '</div>';
                }

                content.innerHTML = html;
            }

            // ========== Render Single Section ==========
            function renderSection(section) {
                let html = '';

                if (section.title) {
                    html += `<h4 class="section-title">${section.title}</h4>`;
                }

                switch (section.type) {
                    case 'text':
                        html += `<p class="section-text">${section.content}</p>`;
                        break;

                    case 'list':
                        html += '<ul class="section-list">';
                        section.content.forEach(item => {
                            html += `<li>${item}</li>`;
                        });
                        html += '</ul>';
                        break;

                    case 'table':
                        html += '<table class="section-table">';
                        section.content.forEach(row => {
                            html += `<tr>
                                <td class="table-key">${row.key}</td>
                                <td class="table-value">${row.value}</td>
                            </tr>`;
                        });
                        html += '</table>';
                        break;

                    case 'feature_list':
                        html += '<div class="feature-list">';
                        section.content.forEach(feature => {
                            const statusClass = feature.completed ? 'completed' : 'pending';
                            const statusIcon = feature.completed ? 'âœ“' : 'â—‹';
                            html += `<div class="feature-item ${statusClass}">
                                <span class="feature-id">#${feature.id}</span>
                                <span class="feature-name">${feature.name}</span>
                                <span class="feature-status">${statusIcon}</span>
                            </div>`;
                        });
                        html += '</div>';
                        break;

                    case 'code':
                        html += `<pre class="section-code"><code>${section.content}</code></pre>`;
                        break;

                    default:
                        html += `<p class="section-text">${JSON.stringify(section.content)}</p>`;
                }

                return `<div class="drawer-section">${html}</div>`;
            }

            // ========== Copy to Clipboard ==========
            function copyToClipboard(text) {
                if (!text) {
                    setStatus("æ— å¯å¤åˆ¶å†…å®¹", "warn");
                    return;
                }

                const fallbackCopy = () => {
                    const textArea = document.createElement("textarea");
                    textArea.value = text;
                    textArea.setAttribute("readonly", "");
                    textArea.style.position = "absolute";
                    textArea.style.left = "-9999px";
                    document.body.appendChild(textArea);
                    textArea.select();

                    try {
                        const ok = document.execCommand("copy");
                        document.body.removeChild(textArea);
                        return ok;
                    } catch (_error) {
                        document.body.removeChild(textArea);
                        return false;
                    }
                };

                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(text).then(() => {
                        setStatus(`å·²å¤åˆ¶: ${text}`, "success");
                    }).catch(err => {
                        console.error("Failed to copy with Clipboard API:", err);
                        if (fallbackCopy()) {
                            setStatus(`å·²å¤åˆ¶: ${text}`, "success");
                        } else {
                            setStatus("å¤åˆ¶å¤±è´¥", "error");
                        }
                    });
                    return;
                }

                if (fallbackCopy()) {
                    setStatus(`å·²å¤åˆ¶: ${text}`, "success");
                } else {
                    window.prompt("æµè§ˆå™¨é™åˆ¶å¤åˆ¶ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ä»¥ä¸‹å‘½ä»¤ï¼š", text);
                    setStatus("å¤åˆ¶å¤±è´¥", "error");
                }
            }

            // ========== Close Drawer ==========
            function closeDrawer() {
                document.getElementById("status-drawer").classList.remove("open");
                statusBarState.activePanel = null;
            }

            // ========== Start Status Polling ==========
            function startStatusPolling() {
                loadStatusSummary(); // Load immediately
                statusBarState.pollingInterval = setInterval(loadStatusSummary, 30000); // 30 seconds
            }

            // ========== Get Panel Title ==========
            function getPanelTitle(panelType) {
                const titles = {
                    progress: "æ€»è¿›åº¦è¯¦æƒ…",
                    next: "ä¸‹ä¸€æ­¥è¯¦æƒ…",
                    plan: "è®¡åˆ’åˆè§„è¯¦æƒ…",
                    risk: "é£é™©é˜»å¡è¯¦æƒ…",
                    snapshot: "å¿«ç…§å†å²"
                };
                return titles[panelType] || "è¯¦æƒ…";
            }

            function parseLoadFileCommand(command) {
                if (!command) {
                    return null;
                }

                const match = /^loadFile\((['"])(.+)\1\)$/.exec(command);
                return match ? match[2] : null;
            }

            // ========== Event Bindings ==========
            // Status bar click events
            document.querySelectorAll(".status-item").forEach(item => {
                item.addEventListener("click", function() {
                    const panel = this.dataset.panel;
                    openDrawer(panel);
                });
            });

            // Refresh button
            document.getElementById("status-refresh-btn").addEventListener("click", async function() {
                this.classList.remove("spinning");
                void this.offsetWidth; // restart animation
                this.classList.add("spinning");

                const success = await loadStatusSummary();
                if (success) {
                    setStatus("Status refreshed", "success");
                }
            });

            document.getElementById("status-refresh-btn").addEventListener("animationend", function() {
                this.classList.remove("spinning");
            });

            // Drawer close button
            document.getElementById("drawer-close-btn").addEventListener("click", closeDrawer);

            document.getElementById("drawer-content").addEventListener("click", (event) => {
                const button = event.target.closest("button");
                if (!button) {
                    return;
                }

                const sourcePath = button.dataset.sourcePath;
                if (sourcePath) {
                    void loadFile(sourcePath);
                    return;
                }

                const actionType = button.dataset.actionType;
                if (!actionType) {
                    return;
                }

                if (actionType === "copy") {
                    copyToClipboard(button.dataset.command || "");
                    return;
                }

                if (actionType === "link") {
                    const command = button.dataset.command || "";
                    const path = parseLoadFileCommand(command);
                    if (path) {
                        void loadFile(path);
                    } else {
                        setStatus("æš‚ä¸æ”¯æŒè¯¥æ“ä½œ", "warn");
                    }
                }
            });

            ui.checkboxMenu.addEventListener("click", (event) => {
                const menuButton = event.target.closest(".checkbox-menu-item");
                if (!menuButton) {
                    return;
                }

                if (state.menuTargetLine === null) {
                    hideCheckboxMenu();
                    return;
                }

                const newStatus = menuButton.dataset.status || " ";
                const targetLine = state.menuTargetLine;
                state.selectedCheckboxLine = targetLine;
                hideCheckboxMenu();
                void updateCheckboxStatus(targetLine, newStatus);
            });

            // [P1 ä¿®å¤] å…³é—­æŒ‰é’®è§¦å‘ç¡®è®¤ï¼šä¸å…è®¸ä»…å…³é—­ UI
            document.getElementById("conflict-drawer-close-btn").addEventListener("click", () => {
                const confirmed = confirm("å…³é—­å†²çªå¼¹çª—å°†æ”¾å¼ƒæœªä¿å­˜çš„ä¿®æ”¹ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ");
                if (confirmed) {
                    clearConflictState();
                }
            });

            // [P1 ä¿®å¤] ç¦ç”¨ backdrop ç‚¹å‡»å…³é—­ï¼Œå¼ºåˆ¶ç”¨æˆ·æ˜¾å¼å†³ç­–
            // document.getElementById("conflict-drawer-backdrop").addEventListener("click", closeConflictDrawer);

            // å†²çªè§£å†³æŒ‰é’®
            document.getElementById("conflict-drawer-content").addEventListener("click", (event) => {
                const button = event.target.closest("button");
                if (!button) return;

                if (button.id === "conflict-merge-btn") {
                    void mergeCheckboxStatus();
                    return;
                }

                if (button.id === "conflict-discard-btn") {
                    void discardAndReload();
                    return;
                }
            });

            window.addEventListener("click", (event) => {
                if (!ui.checkboxMenu.classList.contains("open")) {
                    return;
                }

                const menuClicked = event.target.closest("#checkbox-menu");
                const checkboxClicked = event.target.closest('[data-role="checkbox-control"]');
                if (!menuClicked && !checkboxClicked) {
                    hideCheckboxMenu();
                }
            });

            // Start polling
            buildCheckboxMenu();
            startStatusPolling();
        })();
    </script>
</body>
</html>
