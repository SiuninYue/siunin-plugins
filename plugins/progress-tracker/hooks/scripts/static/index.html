<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Progress Tracker UI</title>
    <style>
        :root {
            --bg-0: #f4efe6;
            --bg-1: #fffaf2;
            --panel: #ffffff;
            --line: #d9d0c2;
            --text-strong: #1f2933;
            --text-soft: #5a6670;
            --accent: #1f7a8c;
            --accent-strong: #155664;
            --warning: #b96f00;
            --danger: #a42f2f;
            --ok: #2f7d32;
            --shadow: 0 8px 24px rgba(31, 41, 51, 0.08);
            --radius: 14px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            font-family: "IBM Plex Sans", "Avenir Next", "Segoe UI", sans-serif;
            color: var(--text-strong);
            background:
                radial-gradient(1100px 380px at 50% -240px, #ffffff 0%, var(--bg-0) 70%),
                linear-gradient(180deg, var(--bg-0) 0%, var(--bg-1) 100%);
        }

        .app {
            max-width: 1240px;
            margin: 0 auto;
            padding: 18px;
            display: grid;
            gap: 14px;
        }

        .topbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: var(--radius);
            padding: 12px 16px;
            box-shadow: var(--shadow);
        }

        .title {
            margin: 0;
            font-size: 1.15rem;
            font-weight: 700;
            letter-spacing: 0.01em;
        }

        .status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            border-radius: 999px;
            border: 1px solid transparent;
            padding: 6px 10px;
            font-size: 0.87rem;
            font-weight: 600;
            color: var(--text-soft);
            background: #f7f3ea;
        }

        .status::before {
            content: "";
            width: 8px;
            height: 8px;
            border-radius: 999px;
            background: currentColor;
            opacity: 0.9;
        }

        .status.info {
            color: var(--accent-strong);
            border-color: rgba(21, 86, 100, 0.28);
            background: rgba(31, 122, 140, 0.08);
        }

        .status.success {
            color: var(--ok);
            border-color: rgba(47, 125, 50, 0.28);
            background: rgba(47, 125, 50, 0.09);
        }

        .status.warn {
            color: var(--warning);
            border-color: rgba(185, 111, 0, 0.3);
            background: rgba(185, 111, 0, 0.1);
        }

        .status.error {
            color: var(--danger);
            border-color: rgba(164, 47, 47, 0.3);
            background: rgba(164, 47, 47, 0.1);
        }

        /* ÂÜ≤Á™ÅÁä∂ÊÄÅ - Á¥´Ëâ≤‰∏ªÈ¢òÔºåÂëºÂê∏Âä®ÁîªÂº∫Ë∞É */
        .status.conflict {
            color: #9333ea;
            border-color: rgba(147, 51, 234, 0.3);
            background: rgba(147, 51, 234, 0.1);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* [‰øÆÊ≠£3] Áã¨Á´ãÂÜ≤Á™Å Drawer CSS Ë°•ÈΩêÔºàÂ§çÁî®Áé∞ÊúâÊ†∑ÂºèÂèòÈáèÔºâ */
        .drawer-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(31, 41, 51, 0.5);
            backdrop-filter: blur(4px);
            z-index: 99;
            opacity: 0;
            pointer-events: none;
            transition: opacity 280ms ease;
        }

        .drawer.open .drawer-backdrop {
            opacity: 1;
            pointer-events: auto;
        }

        .drawer-panel {
            position: fixed;
            top: 0;
            right: -420px;
            width: 420px;
            height: 100vh;
            background: var(--panel);
            border-left: 1px solid var(--line);
            box-shadow: -8px 0 24px rgba(31, 41, 51, 0.12);
            transition: right 280ms cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        /* [P1 ‰øÆÂ§ç] Drawer ÊâìÂºÄÁ±ªÂêç‰∏é CSS ÈÄâÊã©Âô®‰∏ÄËá¥ */
        .drawer.open .drawer-panel {
            right: 0;
        }

        .drawer-header {
            border-bottom: 1px solid var(--line);
            padding: 14px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #ffffff;
        }

        .drawer-header h3 {
            margin: 0;
            font-size: 1.1rem;
        }

        .drawer-close-btn {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: none;
            background: transparent;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .drawer-close-btn:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        /* ÂÜ≤Á™Å Drawer Ê†∑Âºè */
        .conflict-drawer {
            padding: 20px;
        }

        .conflict-table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
        }

        .conflict-table td {
            padding: 8px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .conflict-label {
            color: #6b7280;
            font-size: 13px;
            width: 120px;
        }

        .conflict-value {
            color: #111827;
            font-size: 14px;
            font-weight: 500;
        }

        .conflict-actions {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .conflict-action-btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .conflict-action-btn.primary {
            background: #9333ea;
            color: white;
        }

        .conflict-action-btn.primary:hover {
            background: #7e22ce;
        }

        .conflict-action-btn.secondary {
            background: white;
            color: #dc2626;
            border: 1px solid #dc2626;
        }

        .conflict-action-btn.secondary:hover {
            background: #fef2f2;
        }

        /* ÂÜ≤Á™ÅÂ§ÑÁêÜ‰∏≠Áä∂ÊÄÅ */
        .conflict-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .workspace {
            min-height: 72vh;
            display: grid;
            grid-template-columns: minmax(220px, 300px) minmax(0, 1fr);
            gap: 14px;
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .panel-head {
            border-bottom: 1px solid var(--line);
            padding: 10px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .panel-head h2 {
            margin: 0;
            font-size: 0.96rem;
            letter-spacing: 0.01em;
        }

        .actions {
            display: inline-flex;
            gap: 6px;
        }

        button {
            border: 1px solid var(--line);
            background: #ffffff;
            color: var(--text-strong);
            border-radius: 10px;
            padding: 6px 10px;
            font-size: 0.84rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 120ms ease, border-color 120ms ease, color 120ms ease;
        }

        button:hover {
            border-color: var(--accent);
            color: var(--accent-strong);
            background: rgba(31, 122, 140, 0.08);
        }

        .doc-list {
            list-style: none;
            margin: 0;
            padding: 10px;
            display: grid;
            gap: 6px;
            max-height: calc(72vh - 58px);
            overflow: auto;
        }

        .doc-list li {
            margin: 0;
        }

        .doc-item {
            width: 100%;
            border: 1px solid var(--line);
            border-radius: 10px;
            padding: 8px;
            cursor: pointer;
            display: grid;
            gap: 4px;
            text-align: left;
            transition: border-color 120ms ease, background 120ms ease;
        }

        .doc-item:hover {
            border-color: var(--accent);
            background: rgba(31, 122, 140, 0.07);
        }

        .doc-item:focus-visible {
            outline: 2px solid var(--accent-strong);
            outline-offset: 2px;
        }

        .doc-item.active {
            border-color: var(--accent-strong);
            background: rgba(31, 122, 140, 0.12);
        }

        .doc-name {
            margin: 0;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .doc-meta {
            margin: 0;
            font-size: 0.77rem;
            color: var(--text-soft);
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
        }

        .editor-head {
            border-bottom: 1px solid var(--line);
            padding: 10px 12px;
            display: grid;
            gap: 2px;
        }

        .active-path {
            margin: 0;
            font-size: 0.9rem;
            font-weight: 700;
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .active-time {
            margin: 0;
            color: var(--text-soft);
            font-size: 0.79rem;
        }

        .active-hint {
            margin: 0;
            color: var(--accent-strong);
            font-size: 0.79rem;
            font-weight: 600;
        }

        .refresh-meta {
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            font-size: 0.74rem;
            color: var(--text-soft);
            padding: 0 6px;
            white-space: nowrap;
        }

        .editor {
            margin: 0;
            padding: 14px;
            overflow: auto;
            white-space: normal;
            line-height: 1.6;
            font-size: 0.91rem;
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            min-height: calc(72vh - 58px);
            background-image:
                linear-gradient(180deg, rgba(31, 122, 140, 0.025) 1px, transparent 1px);
            background-size: 100% 1.65rem;
        }

        .empty {
            margin: 0;
            color: var(--text-soft);
            font-style: italic;
        }

        .editor-line {
            display: block;
            min-height: 1.6rem;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .editor-line.checkbox-line {
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .checkbox-btn {
            width: 28px;
            min-width: 28px;
            height: 28px;
            border-radius: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            font-size: 1rem;
            line-height: 1;
        }

        .checkbox-btn.status-space {
            color: var(--text-soft);
        }

        .checkbox-btn.status-slash {
            color: #0d9488;
        }

        .checkbox-btn.status-x {
            color: var(--ok);
        }

        .checkbox-btn.status-dash {
            color: #0f766e;
        }

        .checkbox-btn.status-bang {
            color: var(--danger);
        }

        .checkbox-btn.status-question {
            color: #7c3aed;
        }

        .checkbox-text {
            flex: 1;
            min-width: 0;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .checkbox-menu {
            position: fixed;
            z-index: 200;
            min-width: 180px;
            background: #ffffff;
            border: 1px solid var(--line);
            border-radius: 10px;
            box-shadow: var(--shadow);
            padding: 6px;
            display: none;
        }

        .checkbox-menu.open {
            display: block;
        }

        .checkbox-menu-item {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 8px;
            border: none;
            background: transparent;
            border-radius: 8px;
            padding: 8px 10px;
            text-align: left;
            font-size: 0.83rem;
            color: var(--text-strong);
        }

        .checkbox-menu-item:hover {
            background: rgba(31, 122, 140, 0.08);
            color: var(--accent-strong);
        }

        .checkbox-menu-icon {
            width: 1.2rem;
            text-align: center;
        }

        .checkbox-menu-key {
            margin-left: auto;
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            font-size: 0.76rem;
            color: var(--text-soft);
        }

        @media (max-width: 900px) {
            .workspace {
                grid-template-columns: 1fr;
                min-height: auto;
            }

            .doc-list,
            .editor {
                max-height: 42vh;
                min-height: auto;
            }
        }

        /* ========== Status Bar ========== */
        .status-bar {
            display: flex;
            gap: 8px;
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: var(--radius);
            padding: 10px 12px;
            margin-bottom: 12px;
            box-shadow: var(--shadow);
            align-items: center;
        }

        .status-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid var(--line);
            background: #ffffff;
            text-align: left;
            flex: 1;
            min-width: 0;
            cursor: pointer;
            transition: all 120ms ease;
        }

        .status-item:hover {
            border-color: var(--accent);
            background: rgba(31, 122, 140, 0.08);
            transform: translateY(-1px);
        }

        .status-label {
            font-size: 0.75rem;
            color: var(--text-soft);
            font-weight: 600;
            letter-spacing: 0.02em;
        }

        .status-value {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--text-strong);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Status colors */
        .status-value.ok { color: #10b981; }
        .status-value.warn { color: #f59e0b; }
        .status-value.error { color: #ef4444; }

        .status-refresh {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 1px solid var(--line);
            background: #ffffff;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 120ms ease;
        }

        .status-refresh:hover {
            background: var(--accent);
            color: #ffffff;
        }

        .status-refresh.spinning {
            animation: refresh-spin 420ms linear;
        }

        @keyframes refresh-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* ========== Drawer ========== */
        .drawer {
            position: fixed;
            top: 0;
            right: -420px;
            width: 420px;
            height: 100vh;
            background: var(--panel);
            border-left: 1px solid var(--line);
            box-shadow: -8px 0 24px rgba(31, 41, 51, 0.12);
            transition: right 280ms cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        .drawer.open {
            right: 0;
        }

        .drawer-head {
            border-bottom: 1px solid var(--line);
            padding: 14px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #ffffff;
        }

        .drawer-head h2 {
            font-size: 1.1rem;
            margin: 0;
        }

        .drawer-close {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: none;
            background: transparent;
            font-size: 1.2rem;
            cursor: pointer;
        }

        .drawer-close:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        .drawer-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .drawer-summary {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-strong);
            margin: 0 0 16px 0;
            padding: 10px;
            background: rgba(31, 122, 140, 0.05);
            border-left: 3px solid var(--accent);
            border-radius: 6px;
        }

        .drawer-section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--text-strong);
            margin: 0 0 8px 0;
        }

        .section-text {
            font-size: 0.88rem;
            line-height: 1.6;
            color: var(--text-soft);
            margin: 0;
        }

        .section-list {
            margin: 0;
            padding-left: 20px;
            list-style: disc;
        }

        .section-list li {
            font-size: 0.88rem;
            line-height: 1.6;
            color: var(--text-soft);
            margin-bottom: 6px;
        }

        .section-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.88rem;
        }

        .section-table tr {
            border-bottom: 1px solid var(--line);
        }

        .section-table td {
            padding: 8px 4px;
            vertical-align: top;
        }

        .table-key {
            font-weight: 600;
            color: var(--text-soft);
            width: 35%;
        }

        .table-value {
            color: var(--text-strong);
        }

        .section-code {
            background: rgba(31, 41, 51, 0.04);
            border: 1px solid var(--line);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.82rem;
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            overflow-x: auto;
        }

        .feature-list {
            display: grid;
            gap: 8px;
        }

        .feature-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border: 1px solid var(--line);
            border-radius: 8px;
            background: #ffffff;
            font-size: 0.88rem;
        }

        .feature-item.completed {
            background: rgba(16, 185, 129, 0.05);
            border-color: rgba(16, 185, 129, 0.3);
        }

        .feature-id {
            font-weight: 700;
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            color: var(--accent-strong);
            min-width: 30px;
        }

        .feature-name {
            flex: 1;
            color: var(--text-strong);
        }

        .feature-status {
            font-size: 1.1rem;
            color: var(--ok);
        }

        .drawer-sources,
        .drawer-actions {
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--line);
        }

        .drawer-sources h4,
        .drawer-actions h4 {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-soft);
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .source-btn,
        .action-btn {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            margin-bottom: 8px;
            border: 1px solid var(--line);
            border-radius: 8px;
            background: #ffffff;
            text-align: left;
            cursor: pointer;
            transition: all 120ms ease;
        }

        .source-btn:hover,
        .action-btn:hover {
            border-color: var(--accent);
            background: rgba(31, 122, 140, 0.05);
        }

        .source-icon,
        .action-icon {
            font-size: 1.2rem;
        }

        .source-label,
        .action-label {
            font-size: 0.88rem;
            font-weight: 600;
            color: var(--text-strong);
        }

        .source-path {
            font-size: 0.78rem;
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            color: var(--text-soft);
            margin-left: auto;
        }

        .action-cmd {
            font-size: 0.78rem;
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            color: var(--text-soft);
            margin-left: auto;
            background: rgba(31, 41, 51, 0.04);
            padding: 4px 8px;
            border-radius: 4px;
        }

        /* ========== Help Overlay ========== */
        .help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(31, 41, 51, 0.75);
            backdrop-filter: blur(8px);
            z-index: 300;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .help-overlay.open {
            display: flex;
        }

        .help-panel {
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: var(--radius);
            box-shadow: 0 12px 48px rgba(31, 41, 51, 0.2);
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow: auto;
        }

        .help-header {
            border-bottom: 1px solid var(--line);
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #ffffff;
            border-top-left-radius: var(--radius);
            border-top-right-radius: var(--radius);
        }

        .help-header h2 {
            margin: 0;
            font-size: 1.2rem;
            color: var(--text-strong);
        }

        .help-close {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: none;
            background: transparent;
            font-size: 1.3rem;
            cursor: pointer;
            color: var(--text-soft);
        }

        .help-close:hover {
            background: rgba(0, 0, 0, 0.06);
            color: var(--text-strong);
        }

        .help-content {
            padding: 20px;
        }

        .help-section {
            margin-bottom: 24px;
        }

        .help-section:last-child {
            margin-bottom: 0;
        }

        .help-section h3 {
            margin: 0 0 12px 0;
            font-size: 1rem;
            color: var(--accent-strong);
            font-weight: 700;
        }

        .help-shortcuts {
            display: grid;
            gap: 8px;
        }

        .help-shortcut {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            border: 1px solid var(--line);
            border-radius: 8px;
            background: #ffffff;
        }

        .help-shortcut-desc {
            font-size: 0.9rem;
            color: var(--text-strong);
        }

        .help-shortcut-keys {
            display: flex;
            gap: 6px;
        }

        .help-key {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 28px;
            height: 28px;
            padding: 4px 8px;
            background: rgba(31, 41, 51, 0.06);
            border: 1px solid var(--line);
            border-radius: 6px;
            font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
            font-size: 0.82rem;
            font-weight: 600;
            color: var(--text-strong);
        }

        /* Mobile adaptations */
        @media (max-width: 900px) {
            .status-bar {
                flex-wrap: wrap;
            }

            .status-item {
                flex: 1 1 calc(50% - 4px);
                min-width: 140px;
            }

            .drawer {
                width: 100%;
                right: -100%;
            }

            .drawer.open {
                right: 0;
            }

            .help-panel {
                max-width: 100%;
                max-height: 90vh;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="topbar">
            <h1 class="title">Progress Tracker UI</h1>
            <div id="status-pill" class="status info">Initializing</div>
        </header>

        <!-- Status Bar -->
        <section class="status-bar">
            <button class="status-item" data-panel="progress" title="ÁÇπÂáªÊü•ÁúãËØ¶ÊÉÖ">
                <span class="status-label">ÊÄªËøõÂ∫¶</span>
                <span class="status-value" id="progress-value">-/-</span>
            </button>
            <button class="status-item" data-panel="next" title="ÁÇπÂáªÊü•ÁúãËØ¶ÊÉÖ">
                <span class="status-label">‰∏ã‰∏ÄÊ≠•</span>
                <span class="status-value" id="next-value">-</span>
            </button>
            <button class="status-item" data-panel="plan" title="ÁÇπÂáªÊü•ÁúãËØ¶ÊÉÖ">
                <span class="status-label">ËÆ°ÂàíÂêàËßÑ</span>
                <span class="status-value" id="plan-value">-</span>
            </button>
            <button class="status-item" data-panel="risk" title="ÁÇπÂáªÊü•ÁúãËØ¶ÊÉÖ">
                <span class="status-label">È£éÈô©ÈòªÂ°û</span>
                <span class="status-value" id="risk-value">-</span>
            </button>
            <button class="status-item" data-panel="snapshot" title="ÁÇπÂáªÊü•ÁúãËØ¶ÊÉÖ">
                <span class="status-label">ÊúÄËøëÂø´ÁÖß</span>
                <span class="status-value" id="snapshot-value">-</span>
            </button>
            <button class="status-refresh" id="status-refresh-btn" title="Âà∑Êñ∞Áä∂ÊÄÅ">‚ü≥</button>
        </section>

        <section class="workspace">
            <aside class="panel">
                <div class="panel-head">
                    <h2>Documents</h2>
                    <div class="actions">
                        <button id="refresh-files-btn" type="button">Refresh</button>
                        <span id="refresh-meta" class="refresh-meta">Êú™Âà∑Êñ∞</span>
                    </div>
                </div>
                <ul id="doc-list" class="doc-list"></ul>
            </aside>

            <main class="panel">
                <div class="editor-head">
                    <p id="active-path" class="active-path">No document selected</p>
                    <p id="active-time" class="active-time">Choose a file from the left panel.</p>
                    <p id="editor-hint" class="active-hint">‰ªÖ checkbox Ë°åÔºà- [ ]ÔºâÂèØÁÇπÂáªÂàáÊç¢Áä∂ÊÄÅ„ÄÇ</p>
                </div>
                <div id="editor" class="editor"><p class="empty">Loading document list...</p></div>
            </main>
        </section>

        <!-- Drawer -->
        <aside class="drawer" id="status-drawer">
            <div class="drawer-head">
                <h2 id="drawer-title">ËØ¶ÊÉÖ</h2>
                <button class="drawer-close" id="drawer-close-btn">‚úï</button>
            </div>
            <div class="drawer-content" id="drawer-content">
                <!-- Dynamic content -->
            </div>
        </aside>

        <div class="checkbox-menu" id="checkbox-menu" role="menu" aria-label="Checkbox status menu"></div>

        <!-- ÂÜ≤Á™ÅËß£ÂÜ≥ DrawerÔºàÁã¨Á´ã‰∫éÁä∂ÊÄÅÊ†èËØ¶ÊÉÖ DrawerÔºâ -->
        <div id="conflict-drawer" class="drawer" aria-hidden="true">
            <div class="drawer-backdrop" id="conflict-drawer-backdrop"></div>
            <div class="drawer-panel">
                <div class="drawer-header">
                    <h3 id="conflict-drawer-title">ÂÜ≤Á™ÅËß£ÂÜ≥</h3>
                    <button type="button" class="drawer-close-btn" id="conflict-drawer-close-btn" aria-label="ÂÖ≥Èó≠">‚úï</button>
                </div>
                <div id="conflict-drawer-content" class="drawer-content"></div>
            </div>
        </div>

        <!-- Â∏ÆÂä©ÊµÆÂ±Ç -->
        <div class="help-overlay" id="help-overlay" aria-hidden="true">
            <div class="help-panel">
                <div class="help-header">
                    <h2>‚å®Ô∏è Âø´Êç∑ÈîÆÂ∏ÆÂä©</h2>
                    <button type="button" class="help-close" id="help-close-btn" aria-label="ÂÖ≥Èó≠">‚úï</button>
                </div>
                <div class="help-content">
                    <div class="help-section">
                        <h3>üìÇ ÊñáÊ°£Êìç‰Ωú</h3>
                        <div class="help-shortcuts">
                            <div class="help-shortcut">
                                <span class="help-shortcut-desc">Âà∑Êñ∞ÊñáÊ°£ÂàóË°®</span>
                                <div class="help-shortcut-keys">
                                    <span class="help-key">Ctrl</span>
                                    <span class="help-key">R</span>
                                </div>
                            </div>
                            <div class="help-shortcut">
                                <span class="help-shortcut-desc">Âà∑Êñ∞ÂΩìÂâçÊñáÊ°£</span>
                                <div class="help-shortcut-keys">
                                    <span class="help-key">Ctrl</span>
                                    <span class="help-key">S</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="help-section">
                        <h3>üîÑ Checkbox Êìç‰Ωú</h3>
                        <div class="help-shortcuts">
                            <div class="help-shortcut">
                                <span class="help-shortcut-desc">‰∏ã‰∏Ä‰∏™ Checkbox</span>
                                <div class="help-shortcut-keys">
                                    <span class="help-key">J</span>
                                </div>
                            </div>
                            <div class="help-shortcut">
                                <span class="help-shortcut-desc">‰∏ä‰∏Ä‰∏™ Checkbox</span>
                                <div class="help-shortcut-keys">
                                    <span class="help-key">K</span>
                                </div>
                            </div>
                            <div class="help-shortcut">
                                <span class="help-shortcut-desc">ÂàáÊç¢Áä∂ÊÄÅÔºà‚òê‚ÜíüîÑ‚Üí‚òëÔºâ</span>
                                <div class="help-shortcut-keys">
                                    <span class="help-key">ÁÇπÂáª</span>
                                </div>
                            </div>
                            <div class="help-shortcut">
                                <span class="help-shortcut-desc">ÊòæÁ§∫Áä∂ÊÄÅËèúÂçï</span>
                                <div class="help-shortcut-keys">
                                    <span class="help-key">Âè≥ÈîÆ</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="help-section">
                        <h3>üéØ Áä∂ÊÄÅÂø´Êç∑ÈîÆ</h3>
                        <div class="help-shortcuts">
                            <div class="help-shortcut">
                                <span class="help-shortcut-desc">‚òê Êú™ÂºÄÂßã</span>
                                <div class="help-shortcut-keys">
                                    <span class="help-key">1</span>
                                </div>
                            </div>
                            <div class="help-shortcut">
                                <span class="help-shortcut-desc">üîÑ ËøõË°å‰∏≠</span>
                                <div class="help-shortcut-keys">
                                    <span class="help-key">2</span>
                                </div>
                            </div>
                            <div class="help-shortcut">
                                <span class="help-shortcut-desc">‚òë Â∑≤ÂÆåÊàê</span>
                                <div class="help-shortcut-keys">
                                    <span class="help-key">3</span>
                                </div>
                            </div>
                            <div class="help-shortcut">
                                <span class="help-shortcut-desc">‚ûñ ‰∏çÈÄÇÁî®</span>
                                <div class="help-shortcut-keys">
                                    <span class="help-key">4</span>
                                </div>
                            </div>
                            <div class="help-shortcut">
                                <span class="help-shortcut-desc">‚ùå ÈòªÂ°û</span>
                                <div class="help-shortcut-keys">
                                    <span class="help-key">5</span>
                                </div>
                            </div>
                            <div class="help-shortcut">
                                <span class="help-shortcut-desc">‚ùì ÂæÖÁ°ÆËÆ§</span>
                                <div class="help-shortcut-keys">
                                    <span class="help-key">6</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="help-section">
                        <h3>üîß ÂÖ∂‰ªñ</h3>
                        <div class="help-shortcuts">
                            <div class="help-shortcut">
                                <span class="help-shortcut-desc">ÊòæÁ§∫/ÈöêËóèÂ∏ÆÂä©</span>
                                <div class="help-shortcut-keys">
                                    <span class="help-key">?</span>
                                </div>
                            </div>
                            <div class="help-shortcut">
                                <span class="help-shortcut-desc">ÂÖ≥Èó≠ËèúÂçï/ÂºπÁ™ó</span>
                                <div class="help-shortcut-keys">
                                    <span class="help-key">Esc</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        (() => {
            const state = {
                files: [],
                activePath: null,
                activeRev: "",
                activeMtime: 0,
                selectedCheckboxLine: null,
                menuTargetLine: null,

                // ÂÜ≤Á™ÅÁä∂ÊÄÅÊâ©Â±ïÔºàÊñ∞Â¢ûÔºâ
                conflictData: null,           // ÂÜ≤Á™ÅÂÆåÊï¥‰∏ä‰∏ãÊñá
                pendingCheckboxUpdate: null,  // ÂæÖÂ§ÑÁêÜÁöÑ checkbox Êõ¥Êñ∞
                isSaving: false,              // ‰øùÂ≠ò‰∏≠Ê†áÂøó
                isResolvingConflict: false,   // ÂÜ≤Á™ÅÂ§ÑÁêÜ‰∏≠Ê†áÂøó
                hasPendingConflict: false,    // [‰øÆÊ≠£1] ÊúâÂæÖÂ§ÑÁêÜÂÜ≤Á™ÅÊó∂‰øùÊåÅÈîÅÂÆö
                conflictRetryCount: 0,        // ÂÜ≤Á™ÅÈáçËØïËÆ°Êï∞
                lastRequestId: 0,             // ËØ∑Ê±ÇÂ∫èÂàóÂè∑
                lastRequestTimestamp: 0       // ‰∏äÊ¨°ËØ∑Ê±ÇÊó∂Èó¥Êà≥
            };

            const ui = {
                statusPill: document.getElementById("status-pill"),
                docList: document.getElementById("doc-list"),
                activePath: document.getElementById("active-path"),
                activeTime: document.getElementById("active-time"),
                editorHint: document.getElementById("editor-hint"),
                editor: document.getElementById("editor"),
                refreshFilesBtn: document.getElementById("refresh-files-btn"),
                refreshMeta: document.getElementById("refresh-meta"),
                checkboxMenu: document.getElementById("checkbox-menu")
            };

            const checkboxStateMeta = [
                { char: " ", icon: "‚òê", label: "Êú™ÂºÄÂßã", key: "1", css: "status-space" },
                { char: "/", icon: "üîÑ", label: "ËøõË°å‰∏≠", key: "2", css: "status-slash" },
                { char: "x", icon: "‚òë", label: "Â∑≤ÂÆåÊàê", key: "3", css: "status-x" },
                { char: "-", icon: "‚ûñ", label: "‰∏çÈÄÇÁî®", key: "4", css: "status-dash" },
                { char: "!", icon: "‚ùå", label: "ÈòªÂ°û", key: "5", css: "status-bang" },
                { char: "?", icon: "‚ùì", label: "ÂæÖÁ°ÆËÆ§", key: "6", css: "status-question" }
            ];

            const checkboxStateLookup = new Map(
                checkboxStateMeta.map((item) => [item.char, item])
            );

            const keyboardStatusMap = {
                "1": " ",
                "2": "/",
                "3": "x",
                "4": "-",
                "5": "!",
                "6": "?"
            };

            function setStatus(text, tone = "info") {
                ui.statusPill.textContent = text;
                ui.statusPill.className = "status " + tone;
            }

            /**
             * Áªü‰∏ÄÊ∏ÖÁêÜÂÜ≤Á™ÅÁä∂ÊÄÅÔºàP2 ‰øÆÂ§çÔºâ
             * ÈÅøÂÖçÂêÑÂàÜÊîØÊâãÂ∑• reset ÈÅóÊºèÂØºËá¥Ê∞∏‰πÖÈîÅÊ≠ª
             * @param options.keepDrawer - ÊòØÂê¶‰øùÊåÅ Drawer ÊâìÂºÄÔºàÈªòËÆ§ falseÔºâ
             * @param options.preserveConflictData - ‰øùÊåÅÂÜ≤Á™Å‰∏ä‰∏ãÊñáÁî®‰∫éÈáçËØïÔºàÈªòËÆ§ falseÔºâ
             */
            function clearConflictState(options = {}) {
                const { keepDrawer = false, preserveConflictData = false } = options;

                // ÈùûÈáçËØïÂú∫ÊôØÔºöÊ∏ÖÁêÜÂÜ≤Á™ÅÊï∞ÊçÆ
                if (!preserveConflictData) {
                    state.conflictData = null;
                    state.pendingCheckboxUpdate = null;
                    state.conflictRetryCount = 0;
                }

                // Êìç‰ΩúÊÄÅÊÄªÊòØÊ∏ÖÁêÜ
                state.isResolvingConflict = false;
                state.isSaving = false;

                // ‰ªÖÂú®"‰øùÁïô‰∏ä‰∏ãÊñá + ‰øùÊåÅ Drawer ÊâìÂºÄ"Êó∂‰øùÊåÅÈîÅ
                // Èò≤Ê≠¢ËØØÁî® preserveConflictData ÂØºËá¥ÈöêËóèÈîÅÊ≠ª
                state.hasPendingConflict = keepDrawer && preserveConflictData;

                // ÂÖ≥Èó≠ DrawerÔºàÈô§ÈùûÊåáÂÆö‰øùÊåÅÔºâ
                if (!keepDrawer) {
                    closeConflictDrawer();
                }
            }

            function formatTimestamp(unixSeconds) {
                if (!unixSeconds) {
                    return "Unknown update time";
                }
                const date = new Date(unixSeconds * 1000);
                return date.toLocaleString();
            }

            function setEditorHint(checkboxCount, overrideText = "") {
                if (overrideText) {
                    ui.editorHint.textContent = overrideText;
                    return;
                }

                if (checkboxCount > 0) {
                    ui.editorHint.textContent = `ÂΩìÂâçÊñáÊ°£Êúâ ${checkboxCount} ‰∏™ÂèØÂàáÊç¢ checkboxÔºåÁÇπÂáªÂõæÊ†áÂç≥ÂèØ‰øùÂ≠òÔºàÂø´Êç∑ÈîÆ 1-6Ôºâ`;
                } else {
                    ui.editorHint.textContent = "ÂΩìÂâçÊñáÊ°£Ê≤°ÊúâÂèØÂàáÊç¢ checkboxÔºàÊîØÊåÅ - [ ] / * [ ] / + [ ]Ôºâ";
                }
            }

            function setRefreshMetaLabel(label) {
                ui.refreshMeta.textContent = label;
            }

            function markFileListRefreshed() {
                setRefreshMetaLabel("Â∑≤Âà∑Êñ∞ " + new Date().toLocaleTimeString());
            }

            function splitContentLines(content) {
                const normalized = String(content || "").replace(/\r\n/g, "\n");
                if (!normalized) {
                    return [];
                }
                const lines = normalized.split("\n");
                if (normalized.endsWith("\n")) {
                    lines.pop();
                }
                return lines;
            }

            /**
             * HTML ËΩ¨‰πâÂ∑•ÂÖ∑ÂáΩÊï∞ÔºàÁã¨Á´ãÂÆö‰πâÔºåÂ§çÁî®Áé∞ÊúâÊ®°ÂºèÔºâ
             */
            function escapeHtml(value) {
                return String(value ?? "")
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#39;");
            }

            function parseCheckboxLine(line) {
                const match = /^(\s*[-*+]\s*\[)([ /xX\-!?])(\])(.*)$/.exec(line);
                if (!match) {
                    return null;
                }
                return {
                    status: match[2].toLowerCase(),
                    suffixText: match[4] || ""
                };
            }

            function getNextPrimaryStatus(currentStatus) {
                if (currentStatus === " ") {
                    return "/";
                }
                if (currentStatus === "/") {
                    return "x";
                }
                return " ";
            }

            function normalizeCheckboxState(statusChar) {
                return checkboxStateLookup.get(statusChar) || checkboxStateLookup.get(" ");
            }

            function hideCheckboxMenu() {
                ui.checkboxMenu.classList.remove("open");
                ui.checkboxMenu.style.left = "-9999px";
                ui.checkboxMenu.style.top = "-9999px";
                state.menuTargetLine = null;
            }

            function positionCheckboxMenu(clientX, clientY) {
                const menuRect = ui.checkboxMenu.getBoundingClientRect();
                const viewportPadding = 12;
                const maxLeft = window.innerWidth - menuRect.width - viewportPadding;
                const maxTop = window.innerHeight - menuRect.height - viewportPadding;
                const left = Math.max(viewportPadding, Math.min(clientX, maxLeft));
                const top = Math.max(viewportPadding, Math.min(clientY, maxTop));
                ui.checkboxMenu.style.left = `${left}px`;
                ui.checkboxMenu.style.top = `${top}px`;
            }

            function showCheckboxMenu(clientX, clientY, lineIndex) {
                state.menuTargetLine = lineIndex;
                ui.checkboxMenu.classList.add("open");
                positionCheckboxMenu(clientX, clientY);
            }

            function buildCheckboxMenu() {
                const fragment = document.createDocumentFragment();
                checkboxStateMeta.forEach((meta) => {
                    const item = document.createElement("button");
                    item.type = "button";
                    item.className = "checkbox-menu-item";
                    item.dataset.status = meta.char;
                    item.setAttribute("role", "menuitem");
                    item.innerHTML = `
                        <span class="checkbox-menu-icon">${meta.icon}</span>
                        <span>${meta.label}</span>
                        <span class="checkbox-menu-key">${meta.key}</span>
                    `;
                    fragment.appendChild(item);
                });
                ui.checkboxMenu.replaceChildren(fragment);
            }

            function renderFileList() {
                ui.docList.replaceChildren();

                if (!state.files.length) {
                    const emptyItem = document.createElement("li");
                    emptyItem.className = "empty";
                    emptyItem.textContent = "No markdown files in .claude.";
                    ui.docList.appendChild(emptyItem);
                    return;
                }

                const fragment = document.createDocumentFragment();

                state.files.forEach((file) => {
                    const isActive = file.path === state.activePath;
                    const activeClass = isActive ? "doc-item active" : "doc-item";

                    const listItem = document.createElement("li");
                    const openButton = document.createElement("button");
                    openButton.type = "button";
                    openButton.className = activeClass;
                    openButton.dataset.path = file.path;
                    openButton.setAttribute("aria-label", "Open " + file.path);

                    const name = document.createElement("p");
                    name.className = "doc-name";
                    name.textContent = file.name + ".md";

                    const meta = document.createElement("p");
                    meta.className = "doc-meta";
                    meta.textContent = formatTimestamp(file.mtime);

                    openButton.appendChild(name);
                    openButton.appendChild(meta);
                    openButton.addEventListener("click", () => {
                        void loadFile(file.path);
                    });

                    listItem.appendChild(openButton);
                    fragment.appendChild(listItem);
                });

                ui.docList.appendChild(fragment);
            }

            function renderFileContent(content) {
                ui.editor.replaceChildren();

                const lines = splitContentLines(content);
                if (!lines.length) {
                    const emptyText = document.createElement("p");
                    emptyText.className = "empty";
                    emptyText.textContent = "The selected file is empty.";
                    ui.editor.appendChild(emptyText);
                    setEditorHint(0, "ÂΩìÂâçÊñáÊ°£‰∏∫Á©∫Ôºå‰∏çÂåÖÂê´ÂèØÂàáÊç¢ checkbox");
                    return;
                }

                const fragment = document.createDocumentFragment();
                let checkboxCount = 0;

                lines.forEach((line, lineIndex) => {
                    const checkboxData = parseCheckboxLine(line);
                    const row = document.createElement("div");
                    row.className = "editor-line";
                    row.dataset.lineIndex = String(lineIndex);

                    if (!checkboxData) {
                        row.textContent = line || " ";
                        fragment.appendChild(row);
                        return;
                    }

                    checkboxCount += 1;
                    const statusMeta = normalizeCheckboxState(checkboxData.status);
                    row.classList.add("checkbox-line");

                    const checkboxButton = document.createElement("button");
                    checkboxButton.type = "button";
                    checkboxButton.className = `checkbox-btn ${statusMeta.css}`;
                    checkboxButton.dataset.lineIndex = String(lineIndex);
                    checkboxButton.dataset.status = checkboxData.status;
                    checkboxButton.dataset.role = "checkbox-control";
                    checkboxButton.setAttribute("aria-label", `Checkbox line ${lineIndex + 1}: ${statusMeta.label}`);
                    checkboxButton.textContent = statusMeta.icon;

                    checkboxButton.addEventListener("focus", () => {
                        state.selectedCheckboxLine = lineIndex;
                    });

                    checkboxButton.addEventListener("click", () => {
                        state.selectedCheckboxLine = lineIndex;
                        hideCheckboxMenu();
                        void updateCheckboxStatus(lineIndex, getNextPrimaryStatus(checkboxData.status));
                    });

                    checkboxButton.addEventListener("contextmenu", (event) => {
                        event.preventDefault();
                        state.selectedCheckboxLine = lineIndex;
                        showCheckboxMenu(event.clientX, event.clientY, lineIndex);
                    });

                    const text = document.createElement("span");
                    text.className = "checkbox-text";
                    text.textContent = checkboxData.suffixText || "";

                    row.appendChild(checkboxButton);
                    row.appendChild(text);
                    fragment.appendChild(row);
                });

                ui.editor.appendChild(fragment);
                if (checkboxCount === 0) {
                    state.selectedCheckboxLine = null;
                }
                setEditorHint(checkboxCount);
            }

            async function updateCheckboxStatus(lineIndex, nextStatus) {
                if (!state.activePath) {
                    return;
                }

                // Âπ∂ÂèëÊéßÂà∂ÔºöÂÜ≤Á™ÅÂ§ÑÁêÜ‰∏≠ÊàñÊ≠£Âú®‰øùÂ≠òÊó∂ÈòªÊ≠¢Êìç‰Ωú
                // [‰øÆÊ≠£1] Ê∑ªÂä† hasPendingConflict Ê£ÄÊü•ÔºåÈò≤Ê≠¢ÂÜ≤Á™ÅÂºπÁ™óÊâìÂºÄÊó∂ÁªßÁª≠ÁºñËæë
                if (state.isSaving || state.isResolvingConflict || state.hasPendingConflict) {
                    setStatus("ËØ∑Á≠âÂæÖÂΩìÂâçÊìç‰ΩúÂÆåÊàê", "warn");
                    return;
                }

                // ÊûÑÂª∫Á®≥ÂÅ•Ë°åÁ≠æÂêçÔºàÁî®‰∫éÊúçÂä°Âô®ÂÜÖÂÆπÂåπÈÖçÔºâ
                // ÂÖ≥ÈîÆÔºö‰ΩøÁî®ÈáçÂª∫ÁöÑÂéüÂßã markdown Ë°åÔºåËÄåÈùûÂåÖÂê´ UI ÂõæÊ†áÁöÑ DOM ÊñáÊú¨
                // [‰øÆÊ≠£2] ‰øùÂ≠òÂÆåÊï¥ÂéüÂßãË°åÂâçÁºÄÔºàbullet + indentÔºâÔºå‰∏çÁ°¨ÁºñÁ†Å "-"
                const lineElement = document.querySelector(`.editor-line[data-line-index="${lineIndex}"]`);
                let originalMarkdownLine = "";
                let originalLinePrefix = "";  // [Êñ∞Â¢û] ‰øùÂ≠òÂéüÂßãÂâçÁºÄÔºàbullet + indentÔºâ

                if (lineElement) {
                    const checkboxBtn = lineElement.querySelector('.checkbox-btn');
                    const textSpan = lineElement.querySelector('.checkbox-text');

                    if (checkboxBtn && textSpan) {
                        // [‰øÆÊ≠£2] ÊèêÂèñÂπ∂‰øùÂ≠òÂÆåÊï¥Ë°åÂâçÁºÄÔºàÂåπÈÖçÁé∞Êúâ checkbox Ë°åÊ†ºÂºèÔºâ
                        // ÊîØÊåÅ: "- [ ]", "* [ ]", "+ [ ]", ‰ª•ÂèäÁº©ËøõÂèò‰Ωì
                        const lineText = lineElement.textContent || "";
                        const checkboxMatch = lineText.match(/^(\s*[-*+]\s*\[)([ /xX\-!?])(\])(.*)$/);

                        if (checkboxMatch) {
                            originalLinePrefix = checkboxMatch[1];  // "- [", "* [", "+ [", ÊàñÂ∏¶Áº©Ëøõ
                            const currentStatus = checkboxBtn.dataset.status || " ";
                            const suffixText = textSpan.textContent || "";
                            originalMarkdownLine = `${originalLinePrefix}${currentStatus}]${suffixText}`;
                        }
                    }
                }

                // ÊûÑÂª∫ÂîØ‰∏ÄËØ∑Ê±ÇID
                const requestId = ++state.lastRequestId;
                state.lastRequestTimestamp = Date.now();
                state.isSaving = true;

                setStatus("‰øùÂ≠ò‰∏≠...", "info");

                try {
                    const payload = {
                        file_path: state.activePath,
                        line_index: lineIndex,
                        new_status: nextStatus,
                        base_rev: state.activeRev,
                        base_mtime: state.activeMtime
                    };

                    const result = await fetchJson("/api/checkbox", {
                        method: "PATCH",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload)
                    });

                    state.activeRev = result.rev;
                    state.activeMtime = result.mtime;
                    await loadFile(state.activePath, false);
                    setStatus("Â∑≤‰øùÂ≠ò", "success");

                } catch (error) {
                    if (error && error.status === 409) {
                        // ‰øùÂ≠òÂÜ≤Á™Å‰∏ä‰∏ãÊñá
                        state.pendingCheckboxUpdate = {
                            lineIndex,
                            newStatus: nextStatus,
                            originalMarkdownLine,
                            originalLinePrefix,  // [‰øÆÊ≠£2] ‰øùÂ≠òÂéüÂßãÂâçÁºÄÁî®‰∫éÁ®≥ÂÅ•ÂÆö‰Ωç
                            requestId,
                            targetLine: `checkbox-line-${lineIndex}`
                        };

                        state.conflictRetryCount = 0;

                        // ËøõÂÖ•ÂÜ≤Á™ÅÂ§ÑÁêÜÊµÅÁ®ã
                        await handleConflict(error.payload, requestId);
                    } else {
                        setStatus("‰øùÂ≠òÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï", "error");
                    }
                } finally {
                    // [‰øÆÊ≠£1] ‰ΩøÁî® hasPendingConflict Âà§Êñ≠ÊòØÂê¶‰øùÊåÅÈîÅÂÆö
                    // ‰ªÖÂú®Êó†ÂæÖÂ§ÑÁêÜÂÜ≤Á™ÅÊó∂ÈáçÁΩÆ isSaving
                    if (!state.hasPendingConflict) {
                        state.isSaving = false;
                    }
                }
            }

            async function handleConflict(conflictPayload, requestId) {
                // ËØ∑Ê±ÇËøáÊúüÊ£ÄÊü•
                if (requestId !== state.lastRequestId) {
                    setStatus("ÂÜ≤Á™ÅÂ§ÑÁêÜÂ∑≤ËøáÊúü", "warn");
                    // [P1 ‰øÆÂ§ç] ‰ΩøÁî® clearConflictState Áªü‰∏ÄÊ∏ÖÁêÜ
                    clearConflictState();
                    return;
                }

                state.isResolvingConflict = true;
                state.hasPendingConflict = true;  // [‰øÆÊ≠£1] ‰øùÊåÅÈîÅÂÆöÁõ¥Âà∞ merge/discard ÂÆåÊàê
                setStatus("Ê£ÄÊµãÂà∞ÂÜ≤Á™ÅÔºåÊ≠£Âú®Ëé∑ÂèñÊúÄÊñ∞ÁâàÊú¨...", "warn");

                try {
                    // Ê≠•È™§1: Ëé∑ÂèñÊúçÂä°Âô®ÊúÄÊñ∞ÂÜÖÂÆπ
                    // Ê≥®ÊÑèÔºö‰ΩøÁî® path Êü•ËØ¢ÂèÇÊï∞ÔºàÂêéÁ´ØË¶ÅÊ±ÇÔºâ
                    const serverFile = await fetchJson("/api/file?path=" + encodeURIComponent(state.activePath));

                    // Ê≠•È™§2: Ê†°È™å rev Á°Æ‰øùÊï∞ÊçÆ‰∏ÄËá¥ÊÄß
                    if (serverFile.rev !== conflictPayload.current_rev) {
                        throw new Error("ÊúçÂä°Âô®ÁâàÊú¨Âú®Ëé∑ÂèñËøáÁ®ã‰∏≠Â∑≤Êõ¥Êñ∞");
                    }

                    // Ê≠•È™§3: ‰øùÂ≠òÂÆåÊï¥ÂÜ≤Á™Å‰∏ä‰∏ãÊñáÔºå**Âõ∫ÂåñÊñá‰ª∂Ë∑ØÂæÑ**
                    state.conflictData = {
                        serverRev: serverFile.rev,
                        serverMtime: serverFile.mtime,
                        serverContent: serverFile.content,
                        localRev: state.activeRev,
                        localMtime: state.activeMtime,
                        pendingChange: state.pendingCheckboxUpdate,
                        conflictDetectedAt: Date.now(),
                        filePath: state.activePath  // Âõ∫ÂåñË∑ØÂæÑÔºåÈò≤Ê≠¢ÊñáÊ°£ÂàáÊç¢ÂØºËá¥ÈîôÂÜô
                    };

                    // Ê≠•È™§4: ÊòæÁ§∫ÂÜ≤Á™ÅÂºπÁ™óÔºàÁã¨Á´ã DrawerÔºâ
                    showConflictDrawer();
                    setStatus("Ê£ÄÊµãÂà∞ÂÜ≤Á™Å", "conflict");

                    // [P1 ‰øÆÂ§ç] ‰∏çÈáçÁΩÆÁä∂ÊÄÅÔºå‰øùÊåÅÈîÅÂÆöÁõ¥Âà∞Áî®Êà∑ÂÜ≥Á≠ñ
                    // isResolvingConflict = true; hasPendingConflict = true;

                } catch (fetchError) {
                    console.error("ÂÜ≤Á™ÅÂ§ÑÁêÜÂ§±Ë¥•:", fetchError);

                    // ÈáçËØïÈÄªËæëÔºàÊúÄÂ§ö3Ê¨°ÔºåÊåáÊï∞ÈÄÄÈÅøÔºâ
                    if (state.conflictRetryCount < 3) {
                        state.conflictRetryCount++;
                        const delay = Math.pow(2, state.conflictRetryCount) * 500;

                        setStatus(`Ëé∑ÂèñÂ§±Ë¥•Ôºå${delay/1000}ÁßíÂêéÈáçËØï...`, "warn");
                        await new Promise(resolve => setTimeout(resolve, delay));

                        await handleConflict(conflictPayload, requestId);
                    } else {
                        setStatus("Êó†Ê≥ïËé∑ÂèñÊúÄÊñ∞ÁâàÊú¨ÔºåËØ∑ÊâãÂä®Âà∑Êñ∞", "error");
                        // [P1 ‰øÆÂ§ç] ‰ΩøÁî® clearConflictState Áªü‰∏ÄÊ∏ÖÁêÜ
                        clearConflictState();
                    }
                }
            }

            /**
             * ÊòæÁ§∫ÂÜ≤Á™ÅËß£ÂÜ≥ DrawerÔºàÁã¨Á´ãÁ≥ªÁªüÔºå‰∏çÂΩ±ÂìçÁé∞ÊúâÁä∂ÊÄÅÊ†èËØ¶ÊÉÖÔºâ
             */
            function showConflictDrawer() {
                const conflict = state.conflictData;
                if (!conflict) {
                    setStatus("Êó†ÂÜ≤Á™ÅÊï∞ÊçÆ", "error");
                    return;
                }

                const pending = conflict.pendingChange;
                const currentStatusLabel = getNextStatusLabel(pending.newStatus);

                // ÊûÑÂª∫ÂÜ≤Á™ÅËØ¶ÊÉÖÂÜÖÂÆπ
                const contentHtml = `
                    <div class="conflict-drawer">
                        <table class="conflict-table">
                            <tr><td class="conflict-label">ÊúçÂä°Âô®ÁâàÊú¨Êó∂Èó¥</td><td class="conflict-value">${escapeHtml(formatTimestamp(conflict.serverMtime))}</td></tr>
                            <tr><td class="conflict-label">‰Ω†ÁöÑÁâàÊú¨Êó∂Èó¥</td><td class="conflict-value">${escapeHtml(formatTimestamp(conflict.localMtime))}</td></tr>
                            <tr><td class="conflict-label">‰Ω†ÁöÑ‰øÆÊîπ</td><td class="conflict-value">Ë°å ${pending.lineIndex + 1} ‚Üí ${escapeHtml(currentStatusLabel)}</td></tr>
                        </table>
                        <p style="color: #6b7280; font-size: 13px; margin-top: 16px;">ÈÄâÊã©Ëß£ÂÜ≥ÊñπÂºèÔºö</p>
                        <div class="conflict-actions">
                            <button type="button" class="conflict-action-btn primary" id="conflict-merge-btn">
                                ÈÄêË°å‰øùÁïôÊàëÁöÑÁä∂ÊÄÅÂèòÊõ¥
                            </button>
                            <button type="button" class="conflict-action-btn secondary" id="conflict-discard-btn">
                                ÊîæÂºÉÊàëÁöÑ‰øÆÊîπÔºåÂä†ËΩΩÊúÄÊñ∞ÁâàÊú¨
                            </button>
                        </div>
                    </div>
                `;

                document.getElementById("conflict-drawer-content").innerHTML = contentHtml;
                document.getElementById("conflict-drawer").classList.add("open");
                document.getElementById("conflict-drawer").setAttribute("aria-hidden", "false");
            }

            /**
             * ÂÖ≥Èó≠ÂÜ≤Á™Å Drawer
             */
            function closeConflictDrawer() {
                document.getElementById("conflict-drawer").classList.remove("open");
                document.getElementById("conflict-drawer").setAttribute("aria-hidden", "true");
            }

            /**
             * Ëé∑ÂèñÁä∂ÊÄÅÊ†áÁ≠æÊñáÊú¨
             */
            function getNextStatusLabel(statusChar) {
                const meta = checkboxStateLookup.get(statusChar);
                return meta ? meta.label : statusChar;
            }

            /**
             * Á®≥ÂÅ•ÂêàÂπ∂Áî®Êà∑ÁöÑ checkbox Áä∂ÊÄÅÂèòÊõ¥
             */
            async function mergeCheckboxStatus() {
                const conflict = state.conflictData;
                if (!conflict) {
                    setStatus("Êó†ÂÜ≤Á™ÅÊï∞ÊçÆ", "error");
                    return;
                }

                state.isResolvingConflict = true;
                setStatus("Ê≠£Âú®Á®≥ÂÅ•ÂêàÂπ∂Áä∂ÊÄÅÂèòÊõ¥...", "info");

                // Á¶ÅÁî®ÊåâÈíÆÈò≤Ê≠¢ÈáçÂ§çÁÇπÂáª
                document.getElementById("conflict-merge-btn").disabled = true;
                document.getElementById("conflict-discard-btn").disabled = true;

                try {
                    // 1. Ëß£ÊûêÊúçÂä°Âô®ÂÜÖÂÆπÔºàÂ§çÁî®Áé∞Êúâ splitContentLinesÔºâ
                    const serverLines = splitContentLines(conflict.serverContent);
                    const pending = conflict.pendingChange;

                    // 2. Á®≥ÂÅ•ÂÆö‰ΩçÁõÆÊ†áË°å
                    // [‰øÆÊ≠£2] ‰º†ÂÖ•‰øùÂ≠òÁöÑÂéüÂßãÂâçÁºÄ‰ª•ÊîØÊåÅÁ®≥ÂÅ•ÂåπÈÖç
                    const targetLineIndex = findTargetLineInContent(
                        serverLines,
                        pending.lineIndex,
                        pending.originalMarkdownLine,
                        pending.originalLinePrefix,  // Êñ∞Â¢ûÔºöÂéüÂßãÂâçÁºÄÁî®‰∫éÁ≤æÁ°ÆÂåπÈÖç
                        3
                    );

                    if (targetLineIndex === -1) {
                        setStatus("ÁõÆÊ†áË°åÂ∑≤Ë¢´Âà†Èô§ÊàñÈáçÂÜôÔºåÊó†Ê≥ïÂêàÂπ∂", "warn");
                        await discardAndReload();
                        return;
                    }

                    // 3. Ê£ÄÊü•ÁõÆÊ†áË°åÊòØÂê¶‰ªç‰∏∫ checkbox
                    const serverLine = serverLines[targetLineIndex] || "";
                    const checkboxPattern = /^(\s*[-*+]\s*\[)([ /xX\-!?])(\])(.*)$/;
                    const match = serverLine.match(checkboxPattern);

                    if (!match) {
                        setStatus("ÁõÆÊ†áË°åÂ∑≤Ë¢´‰øÆÊîπ‰∏∫ÈùûcheckboxÔºåÊó†Ê≥ïÂêàÂπ∂", "warn");
                        await discardAndReload();
                        return;
                    }

                    // 4. ÂèëÈÄÅÂêàÂπ∂ËØ∑Ê±ÇÔºà‰ΩøÁî®Âõ∫ÂåñÁöÑÊñá‰ª∂Ë∑ØÂæÑÔºâ
                    const payload = {
                        file_path: conflict.filePath,
                        line_index: targetLineIndex,
                        new_status: pending.newStatus,
                        base_rev: conflict.serverRev,
                        base_mtime: conflict.serverMtime
                    };

                    const result = await fetchJson("/api/checkbox", {
                        method: "PATCH",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload)
                    });

                    // 5. ÊàêÂäüÂêàÂπ∂ÔºöÊ∏ÖÁêÜÁä∂ÊÄÅ
                    state.activeRev = result.rev;
                    state.activeMtime = result.mtime;

                    // 6. ÈáçÊñ∞Âä†ËΩΩÊñá‰ª∂Ôºà‰ΩøÁî®Âõ∫ÂåñÁöÑË∑ØÂæÑÔºâ
                    await loadFile(conflict.filePath, false);

                    // [P1 ‰øÆÂ§ç] ‰ΩøÁî® clearConflictState Áªü‰∏ÄÊ∏ÖÁêÜ
                    clearConflictState({ keepDrawer: false });
                    setStatus("Áä∂ÊÄÅÂèòÊõ¥Â∑≤Á®≥ÂÅ•ÂêàÂπ∂", "success");

                } catch (error) {
                    console.error("ÂêàÂπ∂Â§±Ë¥•:", error);

                    if (error && error.status === 409) {
                        // ‰∫åÊ¨°ÂÜ≤Á™Å
                        state.conflictRetryCount++;

                        if (state.conflictRetryCount <= 3) {
                            const delay = Math.pow(2, state.conflictRetryCount) * 1000;
                            setStatus(`ÂÜçÊ¨°Ê£ÄÊµãÂà∞ÂÜ≤Á™ÅÔºå${delay/1000}ÁßíÂêéÈáçËØï...`, "warn");

                            await new Promise(resolve => setTimeout(resolve, delay));
                            await handleConflict(error.payload, state.lastRequestId);
                        } else {
                            setStatus("Â§öÊ¨°ÂêàÂπ∂Â§±Ë¥•ÔºåÂ∑≤Âä†ËΩΩÊúÄÊñ∞ÁâàÊú¨", "warn");
                            await discardAndReload();
                        }
                    } else {
                        setStatus(`ÂêàÂπ∂Â§±Ë¥•: ${error.message || "Êú™Áü•ÈîôËØØ"}ÔºåËØ∑ÈáçËØïÊàñÊîæÂºÉ‰øÆÊîπ`, "error");
                        // [P1 ‰øÆÂ§ç] ‰øùÊåÅ Drawer ‰∏éÂÜ≤Á™Å‰∏ä‰∏ãÊñáÔºåÂÖÅËÆ∏Áî®Êà∑ÈáçËØï
                        clearConflictState({ keepDrawer: true, preserveConflictData: true });
                        // ÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
                        document.getElementById("conflict-merge-btn").disabled = false;
                        document.getElementById("conflict-discard-btn").disabled = false;
                    }
                }
            }

            /**
             * ÊîæÂºÉ‰øÆÊîπÂπ∂Âä†ËΩΩÊúÄÊñ∞ÁâàÊú¨
             */
            async function discardAndReload() {
                const conflict = state.conflictData;
                if (!conflict) {
                    setStatus("Êó†ÂÜ≤Á™ÅÊï∞ÊçÆ", "error");
                    return;
                }

                state.isResolvingConflict = true;
                setStatus("Ê≠£Âú®Âä†ËΩΩÊúÄÊñ∞ÁâàÊú¨...", "info");

                try {
                    // ‰ΩøÁî®Âõ∫ÂåñÁöÑÊñá‰ª∂Ë∑ØÂæÑ
                    const targetPath = conflict.filePath;

                    // Áõ¥Êé•‰ΩøÁî®Â∑≤Ëé∑ÂèñÁöÑÊúçÂä°Âô®ÂÜÖÂÆπÊ∏≤Êüì
                    state.activeRev = conflict.serverRev;
                    state.activeMtime = conflict.serverMtime;
                    state.activePath = targetPath;  // ÂÖ≥ÈîÆÔºöÊÅ¢Â§ç activePath

                    // Ê∏≤ÊüìÊúçÂä°Âô®ÂÜÖÂÆπ
                    renderFileContent(conflict.serverContent || "");

                    // Êõ¥Êñ∞ UI ÊòæÁ§∫Ë∑ØÂæÑ
                    ui.activePath.textContent = targetPath;
                    ui.activeTime.textContent = formatTimestamp(conflict.serverMtime);

                    // [‰øÆÊ≠£4] Âà∑Êñ∞ÊñáÊ°£ÂàóË°®‰ª•‰øùÊåÅÂ∑¶‰æßÊøÄÊ¥ªÊÄÅ‰∏ÄËá¥
                    renderFileList();

                    // [P1 ‰øÆÂ§ç] ‰ΩøÁî® clearConflictState Áªü‰∏ÄÊ∏ÖÁêÜ
                    clearConflictState({ keepDrawer: false });
                    setStatus("Â∑≤Âä†ËΩΩÊúÄÊñ∞ÁâàÊú¨", "success");

                } catch (error) {
                    console.error("Âä†ËΩΩÊúÄÊñ∞ÁâàÊú¨Â§±Ë¥•:", error);
                    setStatus(`Âä†ËΩΩÂ§±Ë¥•: ${error.message || "Êú™Áü•ÈîôËØØ"}ÔºåËØ∑ÈáçËØïÊàñÁªßÁª≠ÂêàÂπ∂`, "error");
                    // [P1 ‰øÆÂ§ç] ‰øùÊåÅ Drawer ‰∏éÂÜ≤Á™Å‰∏ä‰∏ãÊñáÔºåÂÖÅËÆ∏Áî®Êà∑ÈáçËØï
                    clearConflictState({ keepDrawer: true, preserveConflictData: true });
                    // ÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
                    document.getElementById("conflict-merge-btn").disabled = false;
                    document.getElementById("conflict-discard-btn").disabled = false;
                }
            }

            /**
             * Á®≥ÂÅ•Ë°åÂÆö‰ΩçÁÆóÊ≥ïÔºà‰∫îÁ∫ßÁ≠ñÁï• + P2 ÂçáÁ∫ßÔºâ
             * [‰øÆÊ≠£2] Êñ∞Â¢û originalLinePrefix ÂèÇÊï∞ÔºåÁî®‰∫éÁ≤æÁ°ÆÂâçÁºÄÂåπÈÖç
             * [P2 ÂçáÁ∫ß] ‰ΩøÁî® Jaccard Áõ∏‰ººÂ∫¶Êõø‰ª£Â≠óÁ¨¶ÈõÜÂêàÁõ∏‰ººÂ∫¶
             */
            function findTargetLineInContent(serverLines, originalIndex, originalText, originalLinePrefix, searchRadius = 3) {
                // Á≠ñÁï•0: Á≤æÁ°ÆÂâçÁºÄ+ÊñáÊú¨ÂåπÈÖçÔºàÊúÄÂèØÈù†Ôºâ
                if (originalIndex < serverLines.length) {
                    const line = serverLines[originalIndex];
                    // ‰ΩøÁî®‰øùÂ≠òÁöÑÂéüÂßãÂâçÁºÄËøõË°åÁ≤æÁ°ÆÂåπÈÖç
                    if (line && line.startsWith(originalLinePrefix || "- [")) {
                        const suffixMatch = line.substring((originalLinePrefix || "- [").length).includes(originalText.substring(0, 50));
                        if (suffixMatch) {
                            return originalIndex;
                        }
                    }
                }

                // Á≠ñÁï•1: ÂéüÂßã‰ΩçÁΩÆÁõ¥Êé•ÂåπÈÖç
                if (originalIndex < serverLines.length) {
                    const line = serverLines[originalIndex];
                    if (line && line.includes(originalText.substring(0, 30))) {
                        return originalIndex;
                    }
                }

                // Á≠ñÁï•2: ÊñáÊú¨Á≠æÂêçÂåπÈÖç
                const originalFingerprint = createLineFingerprint(originalText);
                for (let i = 0; i < serverLines.length; i++) {
                    const lineFingerprint = createLineFingerprint(serverLines[i]);
                    if (lineFingerprint === originalFingerprint) {
                        return i;
                    }
                }

                // Á≠ñÁï•3: ÈÇªÂüüÊêúÁ¥¢
                const start = Math.max(0, originalIndex - searchRadius);
                const end = Math.min(serverLines.length - 1, originalIndex + searchRadius);
                for (let i = start; i <= end; i++) {
                    const line = serverLines[i];
                    const checkboxPattern = /^(\s*[-*+]\s*\[)([ /xX\-!?])(\])(.*)$/;
                    if (checkboxPattern.test(line) && line.includes(originalText.substring(0, 50))) {
                        return i;
                    }
                }

                // Á≠ñÁï•4: ÂÖ®ÊñáÊ°£ËåÉÂõ¥ÊêúÁ¥¢Áõ∏‰ººË°å
                const similarityThreshold = 0.8;
                let bestMatch = -1;
                let bestScore = 0;

                for (let i = 0; i < serverLines.length; i++) {
                    const similarity = calculateTextSimilarity(originalText, serverLines[i]);
                    if (similarity > bestScore && similarity >= similarityThreshold) {
                        bestScore = similarity;
                        bestMatch = i;
                    }
                }

                return bestMatch;
            }

            function createLineFingerprint(text) {
                const normalized = text.trim().replace(/\s+/g, ' ').substring(0, 50);
                let hash = 0;
                for (let i = 0; i < normalized.length; i++) {
                    hash = ((hash << 5) - hash) + normalized.charCodeAt(i);
                    hash |= 0;
                }
                return hash.toString(16);
            }

            /**
             * [P2 ÂçáÁ∫ß] ÊñáÊú¨Áõ∏‰ººÂ∫¶ÁÆóÊ≥ï - token bigram Jaccard
             * ÂØπÈ°∫Â∫èÊïèÊÑüÔºåÊØîÂ≠óÁ¨¶ÈõÜÂêàÁõ∏‰ººÂ∫¶Êõ¥ÂèØÈù†Ôºå‰∏îÂÖºÂÆπ‰∏≠Ëã±ÊñáÊ∑∑ÂêàÊñáÊú¨
             */
            function calculateTextSimilarity(text1, text2) {
                if (!text1 || !text2) return 0;

                // ËØçÁ∫ß tokenÔºàËã±ÊñáÂçïËØç + Êï∞Â≠ó + Âçï‰∏™‰∏≠ÊñáÂ≠óÁ¨¶Ôºâ
                const tokenPattern = /[a-z0-9]+|[\u4e00-\u9fa5]/gi;
                const tokens1 = (text1.toLowerCase().match(tokenPattern) || []);
                const tokens2 = (text2.toLowerCase().match(tokenPattern) || []);

                if (tokens1.length === 0 || tokens2.length === 0) return 0;

                // ‰ΩøÁî® bigram ËÆ©È°∫Â∫è‰ø°ÊÅØËøõÂÖ•Áõ∏‰ººÂ∫¶ËÆ°ÁÆó
                const grams1 = tokens1.length > 1
                    ? tokens1.slice(0, -1).map((t, i) => `${t} ${tokens1[i + 1]}`)
                    : tokens1;
                const grams2 = tokens2.length > 1
                    ? tokens2.slice(0, -1).map((t, i) => `${t} ${tokens2[i + 1]}`)
                    : tokens2;

                // Jaccard Áõ∏‰ººÂ∫¶ = |A ‚à© B| / |A ‚à™ B|
                const set1 = new Set(grams1);
                const set2 = new Set(grams2);
                const intersection = new Set([...set1].filter(x => set2.has(x)));
                const union = new Set([...set1, ...set2]);

                return intersection.size / union.size;
            }

            async function fetchJson(url, options = {}) {
                const response = await fetch(url, options);
                let payload = {};

                try {
                    payload = await response.json();
                } catch (_error) {
                    payload = {};
                }

                if (!response.ok) {
                    const message = payload.error || ("Request failed with " + response.status);
                    const error = new Error(message);
                    error.status = response.status;
                    error.payload = payload;
                    throw error;
                }

                return payload;
            }

            async function loadFiles(preserveSelection = true, trigger = "auto") {
                if (trigger === "manual") {
                    setStatus("Ê≠£Âú®Âà∑Êñ∞ÊñáÊ°£ÂàóË°®...", "info");
                } else {
                    setStatus("Ê≠£Âú®Âä†ËΩΩÊñáÊ°£ÂàóË°®...", "info");
                }

                try {
                    const files = await fetchJson("/api/files");
                    state.files = Array.isArray(files) ? files : [];
                    markFileListRefreshed();

                    if (!state.files.length) {
                        state.activePath = null;
                        ui.activePath.textContent = "No document selected";
                        ui.activeTime.textContent = "No files available in .claude/";
                        renderFileList();
                        renderFileContent("");
                        setEditorHint(0, "ÂΩìÂâçÊ≤°ÊúâÂèØÁºñËæëÊñáÊ°£");
                        setStatus("Êú™ÊâæÂà∞ÂèØÁî®ÊñáÊ°£", "warn");
                        return;
                    }

                    if (!preserveSelection || !state.activePath) {
                        state.activePath = state.files[0].path;
                    } else if (!state.files.some((file) => file.path === state.activePath)) {
                        state.activePath = state.files[0].path;
                    }

                    renderFileList();
                    await loadFile(state.activePath, false);
                    if (trigger === "manual") {
                        setStatus("ÊñáÊ°£ÂàóË°®Â∑≤Âà∑Êñ∞", "success");
                    } else {
                        setStatus("Â∑≤Â∞±Áª™", "success");
                    }
                } catch (error) {
                    setStatus("Âä†ËΩΩÊñáÊ°£ÂàóË°®Â§±Ë¥•", "error");
                    setRefreshMetaLabel("Âà∑Êñ∞Â§±Ë¥•");
                    ui.activePath.textContent = "Error";
                    ui.activeTime.textContent = String(error.message || error);
                    ui.editor.textContent = "Unable to load file list.";
                    setEditorHint(0, "Âä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï");
                }
            }

            async function loadFile(path, updateStatus = true) {
                if (!path) {
                    return;
                }

                if (updateStatus) {
                    setStatus("Ê≠£Âú®Âä†ËΩΩ " + path + "...", "info");
                }

                try {
                    const previousPath = state.activePath;
                    const file = await fetchJson("/api/file?path=" + encodeURIComponent(path));
                    state.activePath = file.path;
                    state.activeRev = file.rev;
                    state.activeMtime = file.mtime;
                    if (previousPath !== file.path) {
                        state.selectedCheckboxLine = null;
                    }
                    hideCheckboxMenu();

                    ui.activePath.textContent = file.path;
                    ui.activeTime.textContent = "Last updated: " + formatTimestamp(file.mtime);
                    renderFileContent(file.content || "");
                    renderFileList();
                    if (updateStatus) {
                        setStatus("Â∑≤Â∞±Áª™", "success");
                    }
                } catch (error) {
                    setStatus("Âä†ËΩΩÊñáÊ°£Â§±Ë¥•", "error");
                    ui.activeTime.textContent = String(error.message || error);
                    setEditorHint(0, "Âä†ËΩΩÂ§±Ë¥•ÔºåÊó†Ê≥ïËß£Êûê checkbox");
                }
            }

            ui.refreshFilesBtn.addEventListener("click", () => {
                void loadFiles(true, "manual");
            });

            // ========== Window Focus Refresh ==========
            let lastFocusTime = Date.now();
            const focusRefreshThreshold = 5000; // 5 ÁßíÂêéÊâçËß¶ÂèëÂà∑Êñ∞

            window.addEventListener("focus", async () => {
                const now = Date.now();
                if (now - lastFocusTime > focusRefreshThreshold) {
                    setStatus("Á™óÂè£ËÅöÁÑ¶ÔºåÊ≠£Âú®Âà∑Êñ∞...", "info");
                    await loadFiles(true, "auto");
                    setStatus("Â∑≤Âà∑Êñ∞", "success");
                }
                lastFocusTime = now;
            });

            window.addEventListener("blur", () => {
                lastFocusTime = Date.now();
            });

            // ========== Help Overlay ==========
            function toggleHelpOverlay() {
                const overlay = document.getElementById("help-overlay");
                const isOpen = overlay.classList.contains("open");

                if (isOpen) {
                    overlay.classList.remove("open");
                    overlay.setAttribute("aria-hidden", "true");
                } else {
                    overlay.classList.add("open");
                    overlay.setAttribute("aria-hidden", "false");
                }
            }

            function closeHelpOverlay() {
                const overlay = document.getElementById("help-overlay");
                overlay.classList.remove("open");
                overlay.setAttribute("aria-hidden", "true");
            }

            // ========== Checkbox Navigation ==========
            function navigateToNextCheckbox() {
                const checkboxButtons = Array.from(document.querySelectorAll('.checkbox-btn'));
                if (!checkboxButtons.length) {
                    setStatus("Ê≤°ÊúâÂèØÂØºËà™ÁöÑ checkbox", "warn");
                    return;
                }

                let nextIndex = 0;
                if (state.selectedCheckboxLine !== null) {
                    const currentIndex = checkboxButtons.findIndex(
                        btn => parseInt(btn.dataset.lineIndex) === state.selectedCheckboxLine
                    );
                    nextIndex = (currentIndex + 1) % checkboxButtons.length;
                }

                const nextButton = checkboxButtons[nextIndex];
                state.selectedCheckboxLine = parseInt(nextButton.dataset.lineIndex);
                nextButton.focus();
                nextButton.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            function navigateToPrevCheckbox() {
                const checkboxButtons = Array.from(document.querySelectorAll('.checkbox-btn'));
                if (!checkboxButtons.length) {
                    setStatus("Ê≤°ÊúâÂèØÂØºËà™ÁöÑ checkbox", "warn");
                    return;
                }

                let prevIndex = checkboxButtons.length - 1;
                if (state.selectedCheckboxLine !== null) {
                    const currentIndex = checkboxButtons.findIndex(
                        btn => parseInt(btn.dataset.lineIndex) === state.selectedCheckboxLine
                    );
                    prevIndex = currentIndex > 0 ? currentIndex - 1 : checkboxButtons.length - 1;
                }

                const prevButton = checkboxButtons[prevIndex];
                state.selectedCheckboxLine = parseInt(prevButton.dataset.lineIndex);
                prevButton.focus();
                prevButton.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            window.addEventListener("keydown", (event) => {
                // Ctrl+R: Âà∑Êñ∞ÊñáÊ°£ÂàóË°®
                if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === "r") {
                    event.preventDefault();
                    void loadFiles(true, "manual");
                    return;
                }

                // Ctrl+S: Âà∑Êñ∞ÂΩìÂâçÊñáÊ°£
                if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === "s") {
                    event.preventDefault();
                    if (state.activePath) {
                        void loadFile(state.activePath, true);
                    }
                    return;
                }

                // ?: ÂàáÊç¢Â∏ÆÂä©ÊµÆÂ±Ç
                if (event.key === "?" && !event.ctrlKey && !event.metaKey && !event.altKey) {
                    event.preventDefault();
                    toggleHelpOverlay();
                    return;
                }

                // Escape: ÂÖ≥Èó≠ËèúÂçïÂíåÊµÆÂ±Ç
                if (event.key === "Escape") {
                    const helpOverlay = document.getElementById("help-overlay");
                    if (helpOverlay.classList.contains("open")) {
                        closeHelpOverlay();
                    } else {
                        hideCheckboxMenu();
                    }
                    return;
                }

                // j: ‰∏ã‰∏Ä‰∏™ checkbox
                if (event.key === "j" && !event.ctrlKey && !event.metaKey && !event.altKey) {
                    event.preventDefault();
                    navigateToNextCheckbox();
                    return;
                }

                // k: ‰∏ä‰∏Ä‰∏™ checkbox
                if (event.key === "k" && !event.ctrlKey && !event.metaKey && !event.altKey) {
                    event.preventDefault();
                    navigateToPrevCheckbox();
                    return;
                }

                if (event.ctrlKey || event.metaKey || event.altKey) {
                    return;
                }

                // 1-6: ÂàáÊç¢ checkbox Áä∂ÊÄÅ
                const mappedStatus = keyboardStatusMap[event.key];
                if (!mappedStatus) {
                    return;
                }

                if (state.selectedCheckboxLine === null) {
                    setStatus("ËØ∑ÂÖàÁÇπÂáª‰∏Ä‰∏™ checkbox", "warn");
                    return;
                }

                event.preventDefault();
                hideCheckboxMenu();
                void updateCheckboxStatus(state.selectedCheckboxLine, mappedStatus);
            });

            void loadFiles(false, "initial");

            // ========== Status Bar State Management ==========
            const statusBarState = {
                summary: null,
                activePanel: null,
                pollingInterval: null
            };

            // ========== Document Polling State ==========
            const docPollingState = {
                interval: null,
                currentDelay: 10000,        // ÂàùÂßã 10 Áßí
                minDelay: 10000,            // ÊúÄÂ∞è 10 Áßí
                maxDelay: 30000,            // ÊúÄÂ§ß 30 Áßí
                lastFileCount: 0,
                noChangeCount: 0
            };

            // ========== Load Status Summary ==========
            async function loadStatusSummary() {
                try {
                    const summary = await fetchJson("/api/status-summary");
                    statusBarState.summary = summary;
                    renderStatusBar(summary);
                    return true;
                } catch (error) {
                    console.error("Failed to load status summary:", error);
                    renderStatusBarFallback();
                    setStatus("Failed to load status", "error");
                    return false;
                }
            }

            // ========== Render Status Bar ==========
            function renderStatusBar(summary) {
                const progress = summary.progress || { completed: 0, total: 0, percentage: 0 };
                const nextAction = summary.next_action || { type: "none", feature_id: null, feature_name: "-" };
                const planHealth = summary.plan_health || { status: "N/A" };
                const riskBlocker = summary.risk_blocker || { has_risk: false, message: "-" };
                const recentSnapshot = summary.recent_snapshot || { relative_time: "-" };

                // 1. Progress
                const progressValue = document.getElementById("progress-value");
                progressValue.textContent = `${progress.completed}/${progress.total} (${progress.percentage}%)`;

                // 2. Next Action
                const nextValue = document.getElementById("next-value");
                if (nextAction.type === "feature" && nextAction.feature_id != null) {
                    nextValue.textContent = `#${nextAction.feature_id}`;
                    nextValue.title = nextAction.feature_name || "";
                } else {
                    nextValue.textContent = nextAction.feature_name || "-";
                    nextValue.title = "";
                }

                // 3. Plan Health
                const planValue = document.getElementById("plan-value");
                planValue.textContent = planHealth.status;
                planValue.className = "status-value";
                if (planHealth.status === "OK") {
                    planValue.classList.add("ok");
                } else if (planHealth.status === "WARN") {
                    planValue.classList.add("warn");
                } else if (planHealth.status === "INVALID") {
                    planValue.classList.add("error");
                }

                // 4. Risk Blocker
                const riskValue = document.getElementById("risk-value");
                riskValue.textContent = riskBlocker.message;
                riskValue.className = "status-value";
                if (riskBlocker.has_risk) {
                    riskValue.classList.add("error");
                }

                // 5. Recent Snapshot
                const snapshotValue = document.getElementById("snapshot-value");
                snapshotValue.textContent = recentSnapshot.relative_time;
            }

            function renderStatusBarFallback() {
                const progressValue = document.getElementById("progress-value");
                const nextValue = document.getElementById("next-value");
                const planValue = document.getElementById("plan-value");
                const riskValue = document.getElementById("risk-value");
                const snapshotValue = document.getElementById("snapshot-value");

                progressValue.textContent = "-/-";
                nextValue.textContent = "-";
                nextValue.title = "";
                planValue.textContent = "-";
                planValue.className = "status-value";
                riskValue.textContent = "-";
                riskValue.className = "status-value";
                snapshotValue.textContent = "-";
            }

            // ========== Open Drawer ==========
            async function openDrawer(panelType) {
                statusBarState.activePanel = panelType;

                try {
                    const response = await fetchJson(`/api/status-detail?panel=${panelType}`);
                    renderDrawerContent(panelType, response);

                    document.getElementById("drawer-title").textContent = getPanelTitle(panelType);
                    document.getElementById("status-drawer").classList.add("open");
                } catch (error) {
                    console.error("Failed to load detail:", error);
                    setStatus("Failed to load detail", "error");
                }
            }

            // ========== Render Drawer Content ==========
            function renderDrawerContent(panelType, detail) {
                const content = document.getElementById("drawer-content");
                const escapeHtml = (value) => String(value ?? "")
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#39;");

                // Render summary
                let html = `<p class="drawer-summary">${escapeHtml(detail.summary)}</p>`;

                // Render sections
                detail.sections.forEach(section => {
                    html += renderSection(section);
                });

                // Render sources
                if (detail.sources && detail.sources.length > 0) {
                    html += '<div class="drawer-sources"><h4>Êï∞ÊçÆÊù•Ê∫ê</h4>';
                    detail.sources.forEach(source => {
                        const lineInfo = source.line ? `:${source.line}` : '';
                        html += `<button class="source-btn" type="button" data-source-path="${escapeHtml(source.path)}">
                            <span class="source-icon">üìÑ</span>
                            <span class="source-label">${escapeHtml(source.label)}</span>
                            <span class="source-path">${escapeHtml(source.path)}${escapeHtml(lineInfo)}</span>
                        </button>`;
                    });
                    html += '</div>';
                }

                // Render actions
                if (detail.actions && detail.actions.length > 0) {
                    html += '<div class="drawer-actions"><h4>Âª∫ËÆÆÊìç‰Ωú</h4>';
                    detail.actions.forEach(action => {
                        if (action.type === 'copy') {
                            html += `<button class="action-btn" type="button" data-action-type="copy" data-command="${escapeHtml(action.command)}">
                                <span class="action-icon">üìã</span>
                                <span class="action-label">${escapeHtml(action.label)}</span>
                                <code class="action-cmd">${escapeHtml(action.command)}</code>
                            </button>`;
                        } else if (action.type === 'link') {
                            html += `<button class="action-btn" type="button" data-action-type="link" data-command="${escapeHtml(action.command)}">
                                <span class="action-icon">üîó</span>
                                <span class="action-label">${escapeHtml(action.label)}</span>
                            </button>`;
                        }
                    });
                    html += '</div>';
                }

                content.innerHTML = html;
            }

            // ========== Render Single Section ==========
            function renderSection(section) {
                let html = '';

                if (section.title) {
                    html += `<h4 class="section-title">${section.title}</h4>`;
                }

                switch (section.type) {
                    case 'text':
                        html += `<p class="section-text">${section.content}</p>`;
                        break;

                    case 'list':
                        html += '<ul class="section-list">';
                        section.content.forEach(item => {
                            html += `<li>${item}</li>`;
                        });
                        html += '</ul>';
                        break;

                    case 'table':
                        html += '<table class="section-table">';
                        section.content.forEach(row => {
                            html += `<tr>
                                <td class="table-key">${row.key}</td>
                                <td class="table-value">${row.value}</td>
                            </tr>`;
                        });
                        html += '</table>';
                        break;

                    case 'feature_list':
                        html += '<div class="feature-list">';
                        section.content.forEach(feature => {
                            const statusClass = feature.completed ? 'completed' : 'pending';
                            const statusIcon = feature.completed ? '‚úì' : '‚óã';
                            html += `<div class="feature-item ${statusClass}">
                                <span class="feature-id">#${feature.id}</span>
                                <span class="feature-name">${feature.name}</span>
                                <span class="feature-status">${statusIcon}</span>
                            </div>`;
                        });
                        html += '</div>';
                        break;

                    case 'code':
                        html += `<pre class="section-code"><code>${section.content}</code></pre>`;
                        break;

                    default:
                        html += `<p class="section-text">${JSON.stringify(section.content)}</p>`;
                }

                return `<div class="drawer-section">${html}</div>`;
            }

            // ========== Copy to Clipboard ==========
            function copyToClipboard(text) {
                if (!text) {
                    setStatus("Êó†ÂèØÂ§çÂà∂ÂÜÖÂÆπ", "warn");
                    return;
                }

                const fallbackCopy = () => {
                    const textArea = document.createElement("textarea");
                    textArea.value = text;
                    textArea.setAttribute("readonly", "");
                    textArea.style.position = "absolute";
                    textArea.style.left = "-9999px";
                    document.body.appendChild(textArea);
                    textArea.select();

                    try {
                        const ok = document.execCommand("copy");
                        document.body.removeChild(textArea);
                        return ok;
                    } catch (_error) {
                        document.body.removeChild(textArea);
                        return false;
                    }
                };

                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(text).then(() => {
                        setStatus(`Â∑≤Â§çÂà∂: ${text}`, "success");
                    }).catch(err => {
                        console.error("Failed to copy with Clipboard API:", err);
                        if (fallbackCopy()) {
                            setStatus(`Â∑≤Â§çÂà∂: ${text}`, "success");
                        } else {
                            setStatus("Â§çÂà∂Â§±Ë¥•", "error");
                        }
                    });
                    return;
                }

                if (fallbackCopy()) {
                    setStatus(`Â∑≤Â§çÂà∂: ${text}`, "success");
                } else {
                    window.prompt("ÊµèËßàÂô®ÈôêÂà∂Â§çÂà∂ÔºåËØ∑ÊâãÂä®Â§çÂà∂‰ª•‰∏ãÂëΩ‰ª§Ôºö", text);
                    setStatus("Â§çÂà∂Â§±Ë¥•", "error");
                }
            }

            // ========== Close Drawer ==========
            function closeDrawer() {
                document.getElementById("status-drawer").classList.remove("open");
                statusBarState.activePanel = null;
            }

            // ========== Start Status Polling ==========
            function startStatusPolling() {
                loadStatusSummary(); // Load immediately
                statusBarState.pollingInterval = setInterval(loadStatusSummary, 30000); // 30 seconds
            }

            // ========== Document Polling ==========
            async function pollDocuments() {
                try {
                    const files = await fetchJson("/api/files");
                    const currentFileCount = Array.isArray(files) ? files.length : 0;

                    // Ê£ÄÊµãÂèòÂåñ
                    if (currentFileCount !== docPollingState.lastFileCount) {
                        // ÊúâÂèòÂåñ:Âà∑Êñ∞ÂàóË°®Âπ∂ÈáçÁΩÆÂª∂Ëøü
                        docPollingState.lastFileCount = currentFileCount;
                        docPollingState.noChangeCount = 0;
                        docPollingState.currentDelay = docPollingState.minDelay;

                        await loadFiles(true, "auto");
                    } else {
                        // Êó†ÂèòÂåñ:Âª∂ÈïøÂª∂Ëøü
                        docPollingState.noChangeCount++;
                        if (docPollingState.noChangeCount >= 2) {
                            docPollingState.currentDelay = Math.min(
                                docPollingState.currentDelay + 5000,
                                docPollingState.maxDelay
                            );
                        }
                    }

                    // ÈáçÊñ∞Ë∞ÉÂ∫¶‰∏ã‰∏ÄÊ¨°ËΩÆËØ¢
                    scheduleNextPoll();
                } catch (error) {
                    console.error("Document polling failed:", error);
                    scheduleNextPoll();
                }
            }

            function scheduleNextPoll() {
                if (docPollingState.interval) {
                    clearTimeout(docPollingState.interval);
                }
                docPollingState.interval = setTimeout(pollDocuments, docPollingState.currentDelay);
            }

            function startDocumentPolling() {
                docPollingState.lastFileCount = state.files.length;
                docPollingState.noChangeCount = 0;
                docPollingState.currentDelay = docPollingState.minDelay;
                scheduleNextPoll();
            }

            function stopDocumentPolling() {
                if (docPollingState.interval) {
                    clearTimeout(docPollingState.interval);
                    docPollingState.interval = null;
                }
            }

            // ========== Get Panel Title ==========
            function getPanelTitle(panelType) {
                const titles = {
                    progress: "ÊÄªËøõÂ∫¶ËØ¶ÊÉÖ",
                    next: "‰∏ã‰∏ÄÊ≠•ËØ¶ÊÉÖ",
                    plan: "ËÆ°ÂàíÂêàËßÑËØ¶ÊÉÖ",
                    risk: "È£éÈô©ÈòªÂ°ûËØ¶ÊÉÖ",
                    snapshot: "Âø´ÁÖßÂéÜÂè≤"
                };
                return titles[panelType] || "ËØ¶ÊÉÖ";
            }

            function parseLoadFileCommand(command) {
                if (!command) {
                    return null;
                }

                const match = /^loadFile\((['"])(.+)\1\)$/.exec(command);
                return match ? match[2] : null;
            }

            // ========== Event Bindings ==========
            // Status bar click events
            document.querySelectorAll(".status-item").forEach(item => {
                item.addEventListener("click", function() {
                    const panel = this.dataset.panel;
                    openDrawer(panel);
                });
            });

            // Refresh button
            document.getElementById("status-refresh-btn").addEventListener("click", async function() {
                this.classList.remove("spinning");
                void this.offsetWidth; // restart animation
                this.classList.add("spinning");

                const success = await loadStatusSummary();
                if (success) {
                    setStatus("Status refreshed", "success");
                }
            });

            document.getElementById("status-refresh-btn").addEventListener("animationend", function() {
                this.classList.remove("spinning");
            });

            // Drawer close button
            document.getElementById("drawer-close-btn").addEventListener("click", closeDrawer);

            document.getElementById("drawer-content").addEventListener("click", (event) => {
                const button = event.target.closest("button");
                if (!button) {
                    return;
                }

                const sourcePath = button.dataset.sourcePath;
                if (sourcePath) {
                    void loadFile(sourcePath);
                    return;
                }

                const actionType = button.dataset.actionType;
                if (!actionType) {
                    return;
                }

                if (actionType === "copy") {
                    copyToClipboard(button.dataset.command || "");
                    return;
                }

                if (actionType === "link") {
                    const command = button.dataset.command || "";
                    const path = parseLoadFileCommand(command);
                    if (path) {
                        void loadFile(path);
                    } else {
                        setStatus("ÊöÇ‰∏çÊîØÊåÅËØ•Êìç‰Ωú", "warn");
                    }
                }
            });

            ui.checkboxMenu.addEventListener("click", (event) => {
                const menuButton = event.target.closest(".checkbox-menu-item");
                if (!menuButton) {
                    return;
                }

                if (state.menuTargetLine === null) {
                    hideCheckboxMenu();
                    return;
                }

                const newStatus = menuButton.dataset.status || " ";
                const targetLine = state.menuTargetLine;
                state.selectedCheckboxLine = targetLine;
                hideCheckboxMenu();
                void updateCheckboxStatus(targetLine, newStatus);
            });

            // [P1 ‰øÆÂ§ç] ÂÖ≥Èó≠ÊåâÈíÆËß¶ÂèëÁ°ÆËÆ§Ôºö‰∏çÂÖÅËÆ∏‰ªÖÂÖ≥Èó≠ UI
            document.getElementById("conflict-drawer-close-btn").addEventListener("click", () => {
                const confirmed = confirm("ÂÖ≥Èó≠ÂÜ≤Á™ÅÂºπÁ™óÂ∞ÜÊîæÂºÉÊú™‰øùÂ≠òÁöÑ‰øÆÊîπÔºåÊòØÂê¶ÁªßÁª≠Ôºü");
                if (confirmed) {
                    clearConflictState();
                }
            });

            // [P1 ‰øÆÂ§ç] Á¶ÅÁî® backdrop ÁÇπÂáªÂÖ≥Èó≠ÔºåÂº∫Âà∂Áî®Êà∑ÊòæÂºèÂÜ≥Á≠ñ
            // document.getElementById("conflict-drawer-backdrop").addEventListener("click", closeConflictDrawer);

            // ÂÜ≤Á™ÅËß£ÂÜ≥ÊåâÈíÆ
            document.getElementById("conflict-drawer-content").addEventListener("click", (event) => {
                const button = event.target.closest("button");
                if (!button) return;

                if (button.id === "conflict-merge-btn") {
                    void mergeCheckboxStatus();
                    return;
                }

                if (button.id === "conflict-discard-btn") {
                    void discardAndReload();
                    return;
                }
            });

            window.addEventListener("click", (event) => {
                if (!ui.checkboxMenu.classList.contains("open")) {
                    return;
                }

                const menuClicked = event.target.closest("#checkbox-menu");
                const checkboxClicked = event.target.closest('[data-role="checkbox-control"]');
                if (!menuClicked && !checkboxClicked) {
                    hideCheckboxMenu();
                }
            });

            // Help overlay events
            document.getElementById("help-close-btn").addEventListener("click", closeHelpOverlay);

            document.getElementById("help-overlay").addEventListener("click", (event) => {
                if (event.target.id === "help-overlay") {
                    closeHelpOverlay();
                }
            });

            // Start polling
            buildCheckboxMenu();
            startStatusPolling();
            startDocumentPolling();
        })();
    </script>
</body>
</html>
